<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Training Process - Complete Visualization Suite</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #4a9eff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .panel h3 {
            margin-top: 0;
            color: #4a9eff;
            font-size: 1.2em;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        /* Control Panel Styles */
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            background: rgba(74, 158, 255, 0.05);
            border: 1px solid rgba(74, 158, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 10px;
        }

        .control-section h4 {
            color: #4a9eff;
            margin: 0 0 15px 0;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            padding-bottom: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(45deg, #4a9eff, #0066cc);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(74, 158, 255, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(74, 158, 255, 0.5);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ee5555);
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
        }

        .param-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .param-group label {
            font-size: 0.9em;
            color: #ccc;
            display: flex;
            justify-content: space-between;
        }

        .param-group input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .param-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        /* Phase 1: Learning Rate Scheduler Styles */
        .scheduler-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .scheduler-controls select, .scheduler-controls input {
            background: #333;
            border: 1px solid #666;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        /* Phase 1: Training Alerts Styles */
        .training-alerts {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            display: none;
        }

        .training-alerts.warning {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
        }

        .training-alerts.critical {
            background: rgba(220, 53, 69, 0.1);
            border-color: rgba(220, 53, 69, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .alert-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .alert-body {
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Phase 1: Loss Breakdown Styles */
        .loss-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .loss-component {
            text-align: center;
            background: rgba(74, 158, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(74, 158, 255, 0.2);
        }

        .loss-component-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #4a9eff;
            display: block;
        }

        .loss-component-label {
            font-size: 0.8em;
            color: #888;
            display: block;
        }

        /* Phase 2: Layer-wise Analysis Styles */
        .layer-analysis {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-top: 15px;
        }

        .layer-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(20, 20, 30, 0.5);
        }

        .layer-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-item:hover {
            background: rgba(74, 158, 255, 0.1);
        }

        .layer-item.active {
            background: rgba(74, 158, 255, 0.2);
            border-left: 3px solid #4a9eff;
        }

        .layer-name {
            font-weight: bold;
            color: #4a9eff;
        }

        .layer-stats {
            font-size: 0.8em;
            color: #888;
        }

        .layer-health {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }

        .layer-health.healthy { background: #4ade80; }
        .layer-health.warning { background: #fbbf24; }
        .layer-health.critical { background: #ef4444; }

        .layer-details {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
        }

        .layer-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .layer-metric {
            text-align: center;
            background: rgba(74, 158, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(74, 158, 255, 0.2);
        }

        .layer-metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #4a9eff;
            display: block;
        }

        .layer-metric-label {
            font-size: 0.8em;
            color: #888;
            display: block;
        }

        /* Phase 2: Attention Evolution Styles */
        .attention-evolution {
            margin-top: 15px;
        }

        .evolution-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .evolution-controls select, .evolution-controls input {
            background: #333;
            border: 1px solid #666;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .timeline-scrubber {
            width: 100%;
            margin: 10px 0;
        }

        .attention-frames {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .attention-frame {
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(20, 20, 30, 0.5);
            padding: 5px;
        }

        .attention-frame.active {
            border-color: #4a9eff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        .frame-label {
            text-align: center;
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        /* Phase 2: Model Capacity Visualization Styles */
        .capacity-visualization {
            margin-top: 15px;
        }

        .capacity-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .capacity-controls select {
            background: #333;
            border: 1px solid #666;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .capacity-heatmap {
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(20, 20, 30, 0.3);
            min-height: 200px;
        }

        .capacity-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .capacity-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .capacity-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            border: 1px solid #666;
        }

        /* Phase 2: Interactive Visualization Styles */
        .viz-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .viz-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .viz-tab:hover {
            color: #4a9eff;
        }

        .viz-tab.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
        }

        .viz-content {
            display: none;
        }

        .viz-content.active {
            display: block;
        }

        /* Phase 2: Histogram Styles */
        .histogram-container {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #333;
            min-height: 150px;
        }

        .histogram-bar {
            fill: #4a9eff;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .histogram-bar:hover {
            opacity: 1;
        }

        /* Chart Styles */
        .axis {
            stroke: #666;
            stroke-width: 1;
        }
        
        .axis text {
            fill: #888;
            font-size: 12px;
        }
        
        .grid line {
            stroke: #333;
            stroke-opacity: 0.7;
        }
        
        .loss-line {
            fill: none;
            stroke-width: 2;
        }
        
        .neuron {
            fill: #4a9eff;
            stroke: #fff;
            stroke-width: 1;
            transition: all 0.3s ease;
        }
        
        .neuron.active {
            fill: #ff6b6b;
            filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.8));
        }
        
        .connection {
            stroke: #444;
            stroke-width: 1;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        
        .connection.active {
            stroke: #4a9eff;
            stroke-width: 2;
            opacity: 1;
        }

        .metric-card {
            display: inline-block;
            background: rgba(74, 158, 255, 0.1);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            padding: 10px 20px;
            margin: 5px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4a9eff;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #888;
        }

        .legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .legend-item {
            margin: 0 15px;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 5px;
            border: 1px solid #666;
        }

        /* Phase 3: Data Pipeline & Tokenization Styles */
        .data-pipeline {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .pipeline-section {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
        }

        .pipeline-section h5 {
            color: #4a9eff;
            margin: 0 0 10px 0;
            font-size: 1em;
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            padding-bottom: 5px;
        }

        .token-frequency-chart {
            height: 200px;
            margin-bottom: 15px;
        }

        .sequence-length-dist {
            height: 150px;
            margin-bottom: 15px;
        }

        .batch-composition {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .batch-stat {
            text-align: center;
            background: rgba(74, 158, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(74, 158, 255, 0.2);
        }

        .batch-stat-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #4a9eff;
            display: block;
        }

        .batch-stat-label {
            font-size: 0.8em;
            color: #888;
            display: block;
        }

        .tokenizer-demo {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .tokenizer-input {
            width: 100%;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 10px;
            resize: vertical;
            min-height: 60px;
        }

        .tokenizer-output {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            min-height: 100px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-y: auto;
        }

        .token-item {
            display: inline-block;
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid rgba(74, 158, 255, 0.4);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 2px;
            font-size: 0.8em;
            color: #4a9eff;
        }

        .token-id {
            color: #888;
            font-size: 0.7em;
            margin-left: 4px;
        }

        .encoding-process {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .encoding-step {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(74, 158, 255, 0.05);
            border-left: 3px solid #4a9eff;
            border-radius: 0 5px 5px 0;
        }

        .encoding-step-title {
            font-weight: bold;
            color: #4a9eff;
            font-size: 0.9em;
        }

        .encoding-step-content {
            font-size: 0.8em;
            color: #ccc;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .batch-visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .batch-grid {
            height: 200px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            overflow: hidden;
        }

        .batch-sequence {
            display: flex;
            margin-bottom: 3px;
            height: 12px;
        }

        .batch-token {
            width: 8px;
            height: 10px;
            margin-right: 1px;
            border-radius: 1px;
        }

        .batch-token.text { background: #4a9eff; }
        .batch-token.padding { background: #333; }
        .batch-token.special { background: #fbbf24; }

        .batch-analysis {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 10px;
            border: 1px solid #333;
        }

        .efficiency-meter {
            height: 20px;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid #333;
        }

        .efficiency-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #fbbf24, #4ade80);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        /* Phase 4: Performance Optimization & Analytics Styles */
        .performance-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .performance-metric {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            text-align: center;
        }

        .performance-metric h6 {
            color: #4a9eff;
            margin: 0 0 10px 0;
            font-size: 0.9em;
            font-weight: bold;
        }

        .performance-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .performance-trend {
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .performance-value.excellent { color: #4ade80; }
        .performance-value.good { color: #4a9eff; }
        .performance-value.warning { color: #fbbf24; }
        .performance-value.critical { color: #ef4444; }

        .trend-up { color: #4ade80; }
        .trend-down { color: #ef4444; }
        .trend-stable { color: #888; }

        .optimization-recommendations {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .recommendation-item {
            background: rgba(74, 158, 255, 0.05);
            border-left: 3px solid #4a9eff;
            border-radius: 0 5px 5px 0;
            padding: 10px;
            margin-bottom: 10px;
        }

        .recommendation-title {
            font-weight: bold;
            color: #4a9eff;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .recommendation-description {
            font-size: 0.8em;
            color: #ccc;
            line-height: 1.4;
        }

        .recommendation-impact {
            font-size: 0.75em;
            color: #888;
            margin-top: 5px;
        }

        .recommendation-item.high-impact {
            border-left-color: #ef4444;
        }

        .recommendation-item.medium-impact {
            border-left-color: #fbbf24;
        }

        .recommendation-item.low-impact {
            border-left-color: #4ade80;
        }

        .analytics-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .analytics-tab {
            background: rgba(20, 20, 30, 0.5);
            border: 1px solid #333;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            padding: 8px 15px;
            color: #888;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .analytics-tab.active {
            background: rgba(74, 158, 255, 0.1);
            color: #4a9eff;
            border-color: #4a9eff;
        }

        .analytics-tab:hover {
            background: rgba(74, 158, 255, 0.05);
            color: #4a9eff;
        }

        .analytics-content {
            display: none;
            min-height: 300px;
        }

        .analytics-content.active {
            display: block;
        }

        .resource-monitor {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .resource-gauge {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            text-align: center;
        }

        .gauge-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 10px auto;
        }

        .gauge-background {
            stroke: #333;
            stroke-width: 8;
            fill: none;
        }

        .gauge-foreground {
            stroke: #4a9eff;
            stroke-width: 8;
            fill: none;
            stroke-linecap: round;
            transition: stroke-dasharray 0.3s ease;
        }

        .gauge-text {
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 18px;
            font-weight: bold;
            fill: #4a9eff;
        }

        .heatmap-container {
            width: 100%;
            height: 250px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            overflow: hidden;
        }

        .heatmap-cell {
            stroke: #333;
            stroke-width: 1;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .heatmap-cell:hover {
            opacity: 0.8;
            stroke: #4a9eff;
            stroke-width: 2;
        }

        .timeline-scrubber-container {
            margin: 20px 0;
            padding: 15px;
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            border: 1px solid #333;
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .timeline-slider {
            flex: 1;
            height: 5px;
            background: #333;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .timeline-slider::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }

        .timeline-markers {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .bottleneck-analysis {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .bottleneck-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bottleneck-item:last-child {
            border-bottom: none;
        }

        .bottleneck-component {
            font-weight: bold;
            color: #4a9eff;
        }

        .bottleneck-severity {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .bottleneck-severity.high {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .bottleneck-severity.medium {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .bottleneck-severity.low {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        /* Phase 5: Advanced Training Features Styles */
        .model-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .model-card {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            position: relative;
        }

        .model-card.active {
            border-color: #4a9eff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .model-name {
            font-weight: bold;
            color: #4a9eff;
            font-size: 1.1em;
        }

        .model-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .model-status.training { background: rgba(74, 158, 255, 0.2); color: #4a9eff; }
        .model-status.complete { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .model-status.paused { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }

        .model-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .model-metric {
            text-align: center;
            background: rgba(10, 10, 20, 0.5);
            padding: 8px;
            border-radius: 5px;
        }

        .model-metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #4a9eff;
        }

        .model-metric-label {
            font-size: 0.8em;
            color: #888;
            margin-top: 2px;
        }

        .model-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .model-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #4ade80);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .hyperparameter-optimization {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .optimization-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .optimization-method {
            padding: 6px 12px;
            background: rgba(74, 158, 255, 0.1);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            color: #4a9eff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .optimization-method.active {
            background: rgba(74, 158, 255, 0.3);
        }

        .optimization-method:hover {
            background: rgba(74, 158, 255, 0.2);
        }

        .parameter-space {
            width: 100%;
            height: 200px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .optimization-point {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }

        .optimization-point.best { background: #4ade80; box-shadow: 0 0 8px #4ade80; }
        .optimization-point.good { background: #4a9eff; }
        .optimization-point.poor { background: #ef4444; }
        .optimization-point.current { background: #fbbf24; box-shadow: 0 0 8px #fbbf24; }

        .distributed-training {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .gpu-cluster {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
        }

        .gpu-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .gpu-node {
            aspect-ratio: 1;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            position: relative;
            cursor: pointer;
        }

        .gpu-node.active {
            background: rgba(74, 158, 255, 0.3);
            border-color: #4a9eff;
        }

        .gpu-node.communicating {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(74, 158, 255, 0.5); }
            50% { box-shadow: 0 0 15px rgba(74, 158, 255, 0.8); }
        }

        .communication-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .comm-line {
            stroke: #4a9eff;
            stroke-width: 2;
            opacity: 0.6;
            animation: flow 2s infinite;
        }

        @keyframes flow {
            0% { stroke-dasharray: 5 5; stroke-dashoffset: 0; }
            100% { stroke-dasharray: 5 5; stroke-dashoffset: 10; }
        }

        .text-generation {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .generation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .prompt-input {
            flex: 1;
            min-width: 200px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
        }

        .generate-btn {
            background: linear-gradient(45deg, #4ade80, #22c55e);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .generate-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }

        .generated-text {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            min-height: 120px;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .generated-token {
            display: inline;
            padding: 1px 3px;
            margin: 1px;
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        .generated-token.new {
            background: rgba(74, 158, 255, 0.3);
            animation: tokenAppear 0.5s ease;
        }

        @keyframes tokenAppear {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }

        .memory-profiler {
            background: rgba(20, 20, 30, 0.3);
            border-radius: 5px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .memory-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .memory-segment {
            text-align: center;
            background: rgba(10, 10, 20, 0.5);
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid;
        }

        .memory-segment.weights { border-left-color: #4a9eff; }
        .memory-segment.activations { border-left-color: #4ade80; }
        .memory-segment.gradients { border-left-color: #fbbf24; }
        .memory-segment.optimizer { border-left-color: #ef4444; }
        .memory-segment.cache { border-left-color: #a855f7; }

        .memory-value {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .memory-label {
            font-size: 0.8em;
            color: #888;
        }

        .memory-timeline {
            width: 100%;
            height: 100px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .control-panel {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .scheduler-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .loss-breakdown {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Large Language Model Training Process</h1>
        <div class="subtitle">🎉 Complete Suite: Training Dynamics + Architecture + Data Pipeline + Performance Analytics</div>
        
        <!-- Enhanced Control Panel -->
        <div class="panel full-width">
            <h3>🎮 Training Control Center</h3>
            <div class="control-panel">
                <div class="control-section">
                    <h4>Training Controls</h4>
                    <div class="button-group">
                        <button id="play-btn" class="control-btn active">▶️ Play</button>
                        <button id="pause-btn" class="control-btn">⏸️ Pause</button>
                        <button id="reset-btn" class="control-btn">🔄 Reset</button>
                    </div>
                    <div class="speed-control">
                        <label>Speed: <span id="speed-value">1x</span></label>
                        <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1">
                    </div>
                </div>
                <div class="control-section">
                    <h4>Hyperparameters</h4>
                    <div class="param-controls">
                        <div class="param-group">
                            <label>Learning Rate: <span id="lr-value">0.001</span></label>
                            <input type="range" id="lr-slider" min="0.0001" max="0.01" step="0.0001" value="0.001">
                        </div>
                        <div class="param-group">
                            <label>Batch Size: <span id="batch-value">32</span></label>
                            <input type="range" id="batch-slider" min="8" max="128" step="8" value="32">
                        </div>
                        <div class="param-group">
                            <label>Dropout: <span id="dropout-value">0.1</span></label>
                            <input type="range" id="dropout-slider" min="0" max="0.5" step="0.01" value="0.1">
                        </div>
                        <div class="param-group">
                            <label>Attention Heads: <span id="heads-value">8</span></label>
                            <input type="range" id="heads-slider" min="1" max="16" step="1" value="8">
                        </div>
                    </div>
                    
                    <!-- Phase 1: Learning Rate Scheduling -->
                    <h4>📈 Learning Rate Schedule</h4>
                    <div class="scheduler-controls">
                        <label>Scheduler:</label>
                        <select id="scheduler-select">
                            <option value="constant">Constant</option>
                            <option value="cosine" selected>Cosine Annealing</option>
                            <option value="step">Step Decay</option>
                            <option value="warmup">Warmup + Cosine</option>
                            <option value="exponential">Exponential Decay</option>
                        </select>
                        <label>Warmup Steps:</label>
                        <input type="number" id="warmup-steps" min="0" max="1000" value="100" style="width: 80px;">
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <!-- Training Progress Panel -->
            <div class="panel full-width">
                <h3>📊 Training Progress Overview</h3>
                <div id="progress-chart"></div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4a9eff;"></div>
                        <span>Training Loss</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Validation Loss</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ade80;"></div>
                        <span>Learning Rate</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #fbbf24;"></div>
                        <span>Gradient Norm</span>
                    </div>
                </div>
            </div>
            
            <!-- Phase 1: Training Health Monitor -->
            <div class="panel full-width">
                <h3>🚨 Training Health Monitor</h3>
                <div id="training-alerts" class="training-alerts">
                    <div class="alert-header">
                        <span id="alert-icon">⚠️</span>
                        <span id="alert-title">Training Alert</span>
                    </div>
                    <div class="alert-body" id="alert-message">
                        Monitoring training stability...
                    </div>
                </div>
                
                <!-- Loss Component Breakdown -->
                <div class="loss-breakdown">
                    <div class="loss-component">
                        <span class="loss-component-value" id="cross-entropy-loss">2.45</span>
                        <span class="loss-component-label">Cross Entropy</span>
                    </div>
                    <div class="loss-component">
                        <span class="loss-component-value" id="regularization-loss">0.023</span>
                        <span class="loss-component-label">Regularization</span>
                    </div>
                    <div class="loss-component">
                        <span class="loss-component-value" id="total-loss">2.473</span>
                        <span class="loss-component-label">Total Loss</span>
                    </div>
                    <div class="loss-component">
                        <span class="loss-component-value" id="loss-variance">0.12</span>
                        <span class="loss-component-label">Loss Variance</span>
                    </div>
                    <div class="loss-component">
                        <span class="loss-component-value" id="convergence-rate">95.2%</span>
                        <span class="loss-component-label">Convergence</span>
                    </div>
                    <div class="loss-component">
                        <span class="loss-component-value" id="training-efficiency">87.3%</span>
                        <span class="loss-component-label">Efficiency</span>
                    </div>
                </div>
            </div>
            
            <!-- Neural Network Architecture -->
            <div class="panel">
                <h3>🧠 Transformer Architecture</h3>
                <div id="network-viz"></div>
            </div>
            
            <!-- Phase 2: Layer-wise Analysis Dashboard -->
            <div class="panel full-width">
                <h3>🔍 Layer-wise Analysis Dashboard</h3>
                <div class="layer-analysis">
                    <div class="layer-list" id="layer-list">
                        <!-- Layer items will be populated by JavaScript -->
                    </div>
                    <div class="layer-details">
                        <h4 id="selected-layer-name">Select a layer to view details</h4>
                        <div class="layer-metrics" id="layer-metrics">
                            <!-- Layer metrics will be populated by JavaScript -->
                        </div>
                        <div class="histogram-container" id="layer-histogram">
                            <!-- Layer histogram will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 2: Attention Pattern Evolution -->
            <div class="panel">
                <h3>👁️ Attention Pattern Evolution</h3>
                <div class="attention-evolution">
                    <div class="evolution-controls">
                        <label>Head:</label>
                        <select id="evolution-head-selector">
                            <option value="0">Head 1</option>
                            <option value="1">Head 2</option>
                            <option value="2">Head 3</option>
                            <option value="3">Head 4</option>
                            <option value="4" selected>Head 5</option>
                        </select>
                        <label>Layer:</label>
                        <select id="evolution-layer-selector">
                            <option value="0">Layer 1</option>
                            <option value="5" selected>Layer 6</option>
                            <option value="11">Layer 12</option>
                        </select>
                        <button id="play-evolution" class="control-btn">▶️ Play Evolution</button>
                    </div>
                    <div class="timeline-scrubber">
                        <label>Training Progress:</label>
                        <input type="range" id="evolution-timeline" min="0" max="100" value="50" style="width: 100%;">
                    </div>
                    <div id="attention-evolution-viz"></div>
                    <div class="attention-frames" id="attention-frames">
                        <!-- Attention frames will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Phase 2: Model Capacity Visualization -->
            <div class="panel">
                <h3>📊 Model Capacity & Utilization</h3>
                <div class="capacity-visualization">
                    <div class="viz-tabs">
                        <button class="viz-tab active" data-tab="weight-magnitude">Weight Magnitude</button>
                        <button class="viz-tab" data-tab="gradient-flow">Gradient Flow</button>
                        <button class="viz-tab" data-tab="activation-stats">Activation Stats</button>
                    </div>
                    
                    <div class="viz-content active" id="weight-magnitude">
                        <div class="capacity-controls">
                            <label>Visualization:</label>
                            <select id="capacity-viz-type">
                                <option value="heatmap" selected>Layer Heatmap</option>
                                <option value="distribution">Weight Distribution</option>
                                <option value="utilization">Parameter Utilization</option>
                            </select>
                            <label>Metric:</label>
                            <select id="capacity-metric">
                                <option value="magnitude">Weight Magnitude</option>
                                <option value="sparsity">Sparsity</option>
                                <option value="updates">Recent Updates</option>
                            </select>
                        </div>
                        <div class="capacity-heatmap" id="capacity-heatmap"></div>
                        <div class="capacity-legend">
                            <div class="capacity-legend-item">
                                <div class="capacity-color" style="background: #1f2937;"></div>
                                <span>Low</span>
                            </div>
                            <div class="capacity-legend-item">
                                <div class="capacity-color" style="background: #4a9eff;"></div>
                                <span>Medium</span>
                            </div>
                            <div class="capacity-legend-item">
                                <div class="capacity-color" style="background: #ef4444;"></div>
                                <span>High</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-content" id="gradient-flow">
                        <div id="gradient-flow-viz"></div>
                    </div>
                    
                    <div class="viz-content" id="activation-stats">
                        <div id="activation-stats-viz"></div>
                    </div>
                </div>
            </div>
            
            <!-- Training Metrics -->
            <div class="panel">
                <h3>📈 Live Training Metrics</h3>
                <div id="metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="epoch">0</div>
                        <div class="metric-label">Epoch</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="batch">0</div>
                        <div class="metric-label">Batch</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="tokens">0</div>
                        <div class="metric-label">Tokens (B)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="perplexity">0</div>
                        <div class="metric-label">Perplexity</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="gpu-util">78%</div>
                        <div class="metric-label">GPU Util</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="memory-use">12.4GB</div>
                        <div class="metric-label">Memory</div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 3: Data Pipeline Visualization -->
            <div class="panel full-width">
                <h3>📊 Data Pipeline & Statistics</h3>
                <div class="data-pipeline">
                    <div class="pipeline-section">
                        <h5>Token Frequency Distribution</h5>
                        <div class="token-frequency-chart" id="token-frequency-chart"></div>
                        <div class="batch-composition">
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="vocab-size">32,000</span>
                                <span class="batch-stat-label">Vocab Size</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="unique-tokens">8,432</span>
                                <span class="batch-stat-label">Unique Tokens</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="oov-rate">2.3%</span>
                                <span class="batch-stat-label">OOV Rate</span>
                            </div>
                        </div>
                    </div>
                    <div class="pipeline-section">
                        <h5>Sequence Length Distribution</h5>
                        <div class="sequence-length-dist" id="sequence-length-dist"></div>
                        <div class="batch-composition">
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="avg-seq-length">127</span>
                                <span class="batch-stat-label">Avg Length</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="max-seq-length">512</span>
                                <span class="batch-stat-label">Max Length</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="padding-ratio">18.2%</span>
                                <span class="batch-stat-label">Padding %</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 3: Interactive Tokenizer -->
            <div class="panel">
                <h3>🔤 Interactive Tokenizer Demo</h3>
                <div class="tokenizer-demo">
                    <label for="tokenizer-input">Enter text to tokenize:</label>
                    <textarea id="tokenizer-input" class="tokenizer-input" placeholder="The quick brown fox jumps over the lazy dog. This is a sample text for tokenization demonstration.">The quick brown fox jumps over the lazy dog.</textarea>
                    <button id="tokenize-btn" class="control-btn">🔍 Tokenize</button>
                    
                    <h5>Tokenized Output:</h5>
                    <div id="tokenizer-output" class="tokenizer-output">
                        <!-- Tokens will be displayed here -->
                    </div>
                    
                    <div class="encoding-process" id="encoding-process">
                        <h5>Encoding Process:</h5>
                        <!-- Encoding steps will be displayed here -->
                    </div>
                </div>
            </div>
            
            <!-- Phase 3: Batch Composition Analysis -->
            <div class="panel">
                <h3>📦 Batch Composition Analysis</h3>
                <div class="batch-visualization">
                    <div>
                        <h5>Current Batch Visualization</h5>
                        <div class="batch-grid" id="batch-grid">
                            <!-- Batch sequences will be visualized here -->
                        </div>
                        <div style="font-size: 0.8em; color: #888; margin-top: 10px;">
                            <span style="color: #4a9eff;">■</span> Text Tokens
                            <span style="color: #333; margin-left: 15px;">■</span> Padding
                            <span style="color: #fbbf24; margin-left: 15px;">■</span> Special Tokens
                        </div>
                    </div>
                    <div class="batch-analysis">
                        <h5>Batch Efficiency Analysis</h5>
                        <div>
                            <label>Batch Efficiency: <span id="batch-efficiency-value">82.3%</span></label>
                            <div class="efficiency-meter">
                                <div class="efficiency-fill" id="efficiency-fill" style="width: 82.3%;"></div>
                            </div>
                        </div>
                        <div class="batch-composition">
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="batch-diversity">0.87</span>
                                <span class="batch-stat-label">Diversity</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="batch-samples">32</span>
                                <span class="batch-stat-label">Samples</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="effective-tokens">13,242</span>
                                <span class="batch-stat-label">Effective Tokens</span>
                            </div>
                            <div class="batch-stat">
                                <span class="batch-stat-value" id="wasted-compute">17.7%</span>
                                <span class="batch-stat-label">Wasted Compute</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 4: Performance Optimization Dashboard -->
            <div class="panel full-width">
                <h3>⚡ Performance Optimization Dashboard</h3>
                <div class="performance-dashboard">
                    <div class="performance-metric">
                        <h6>Training Efficiency</h6>
                        <div class="performance-value excellent" id="training-efficiency">94.2%</div>
                        <div class="performance-trend">
                            <span class="trend-up">↗</span>
                            <span>+2.1% from baseline</span>
                        </div>
                    </div>
                    <div class="performance-metric">
                        <h6>GPU Utilization</h6>
                        <div class="performance-value good" id="gpu-utilization">87.4%</div>
                        <div class="performance-trend">
                            <span class="trend-stable">→</span>
                            <span>Stable</span>
                        </div>
                    </div>
                    <div class="performance-metric">
                        <h6>Memory Efficiency</h6>
                        <div class="performance-value warning" id="memory-efficiency">76.8%</div>
                        <div class="performance-trend">
                            <span class="trend-down">↘</span>
                            <span>-3.2% optimization needed</span>
                        </div>
                    </div>
                    <div class="performance-metric">
                        <h6>Throughput</h6>
                        <div class="performance-value excellent" id="throughput">2,340</div>
                        <div class="performance-trend">
                            <span class="trend-up">↗</span>
                            <span>tokens/sec</span>
                        </div>
                    </div>
                    <div class="performance-metric">
                        <h6>Cost Efficiency</h6>
                        <div class="performance-value good" id="cost-efficiency">$0.024</div>
                        <div class="performance-trend">
                            <span class="trend-stable">→</span>
                            <span>per 1K tokens</span>
                        </div>
                    </div>
                    <div class="performance-metric">
                        <h6>Time to Convergence</h6>
                        <div class="performance-value good" id="convergence-time">2.4h</div>
                        <div class="performance-trend">
                            <span class="trend-up">↗</span>
                            <span>15% faster</span>
                        </div>
                    </div>
                </div>
                
                <div class="optimization-recommendations">
                    <h5>🎯 Optimization Recommendations</h5>
                    <div id="recommendations-list">
                        <!-- Recommendations will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Phase 4: Advanced Analytics -->
            <div class="panel full-width">
                <h3>📊 Advanced Training Analytics</h3>
                <div class="analytics-tabs">
                    <button class="analytics-tab active" data-tab="resource-monitor">Resource Monitor</button>
                    <button class="analytics-tab" data-tab="bottleneck-analysis">Bottleneck Analysis</button>
                    <button class="analytics-tab" data-tab="gradient-analysis">Gradient Analysis</button>
                    <button class="analytics-tab" data-tab="convergence-prediction">Convergence Prediction</button>
                </div>
                
                <div class="analytics-content active" id="resource-monitor">
                    <div class="resource-monitor">
                        <div class="resource-gauge">
                            <h6>GPU Memory</h6>
                            <div class="gauge-container">
                                <svg width="120" height="120">
                                    <circle cx="60" cy="60" r="45" class="gauge-background"></circle>
                                    <circle cx="60" cy="60" r="45" class="gauge-foreground" id="gpu-memory-gauge"
                                            stroke-dasharray="0 283" transform="rotate(-90 60 60)"></circle>
                                    <text x="60" y="60" class="gauge-text" id="gpu-memory-text">78%</text>
                                </svg>
                            </div>
                            <div style="font-size: 0.8em; color: #888;">14.2GB / 24.0GB</div>
                        </div>
                        <div class="resource-gauge">
                            <h6>CPU Usage</h6>
                            <div class="gauge-container">
                                <svg width="120" height="120">
                                    <circle cx="60" cy="60" r="45" class="gauge-background"></circle>
                                    <circle cx="60" cy="60" r="45" class="gauge-foreground" id="cpu-usage-gauge"
                                            stroke-dasharray="0 283" transform="rotate(-90 60 60)"></circle>
                                    <text x="60" y="60" class="gauge-text" id="cpu-usage-text">45%</text>
                                </svg>
                            </div>
                            <div style="font-size: 0.8em; color: #888;">18 / 32 cores</div>
                        </div>
                    </div>
                    
                    <div class="timeline-scrubber-container">
                        <h6>Resource Usage Timeline</h6>
                        <div class="timeline-controls">
                            <button id="timeline-play" class="control-btn">▶️</button>
                            <input type="range" id="timeline-slider" class="timeline-slider" min="0" max="100" value="50">
                            <span id="timeline-time">12:34:56</span>
                        </div>
                        <div class="timeline-markers">
                            <span>Start</span>
                            <span>25%</span>
                            <span>50%</span>
                            <span>75%</span>
                            <span>Current</span>
                        </div>
                        <div class="heatmap-container" id="resource-timeline-heatmap">
                            <!-- Resource timeline heatmap will be rendered here -->
                        </div>
                    </div>
                </div>
                
                <div class="analytics-content" id="bottleneck-analysis">
                    <div class="bottleneck-analysis">
                        <h6>Current Bottlenecks</h6>
                        <div id="bottleneck-list">
                            <!-- Bottleneck items will be populated by JavaScript -->
                        </div>
                    </div>
                    <div class="heatmap-container" id="bottleneck-heatmap">
                        <!-- Bottleneck heatmap will be rendered here -->
                    </div>
                </div>
                
                <div class="analytics-content" id="gradient-analysis">
                    <div class="heatmap-container" id="gradient-flow-heatmap">
                        <!-- Gradient flow heatmap will be rendered here -->
                    </div>
                </div>
                
                <div class="analytics-content" id="convergence-prediction">
                    <div class="heatmap-container" id="convergence-prediction-chart">
                        <!-- Convergence prediction chart will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Phase 5: Model Comparison Dashboard -->
            <div class="panel full-width">
                <h3>🔬 Model Comparison Dashboard</h3>
                <div class="model-comparison">
                    <div class="model-card active" id="model-a">
                        <div class="model-header">
                            <span class="model-name">GPT-3.5 (Base)</span>
                            <span class="model-status training">Training</span>
                        </div>
                        <div class="model-metrics">
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-a-loss">2.47</div>
                                <div class="model-metric-label">Loss</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-a-perplexity">11.8</div>
                                <div class="model-metric-label">Perplexity</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-a-accuracy">76.2%</div>
                                <div class="model-metric-label">Accuracy</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-a-speed">2.1k</div>
                                <div class="model-metric-label">Tokens/sec</div>
                            </div>
                        </div>
                        <div>Architecture: 12 layers, 768 hidden, 12 heads</div>
                        <div class="model-progress-bar">
                            <div class="model-progress-fill" id="model-a-progress" style="width: 65%;"></div>
                        </div>
                    </div>
                    
                    <div class="model-card" id="model-b">
                        <div class="model-header">
                            <span class="model-name">GPT-4 (Optimized)</span>
                            <span class="model-status training">Training</span>
                        </div>
                        <div class="model-metrics">
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-b-loss">1.89</div>
                                <div class="model-metric-label">Loss</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-b-perplexity">6.6</div>
                                <div class="model-metric-label">Perplexity</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-b-accuracy">84.7%</div>
                                <div class="model-metric-label">Accuracy</div>
                            </div>
                            <div class="model-metric">
                                <div class="model-metric-value" id="model-b-speed">1.8k</div>
                                <div class="model-metric-label">Tokens/sec</div>
                            </div>
                        </div>
                        <div>Architecture: 24 layers, 1024 hidden, 16 heads</div>
                        <div class="model-progress-bar">
                            <div class="model-progress-fill" id="model-b-progress" style="width: 58%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 5: Hyperparameter Optimization -->
            <div class="panel">
                <h3>🎯 Hyperparameter Optimization</h3>
                <div class="hyperparameter-optimization">
                    <div class="optimization-controls">
                        <span style="color: #4a9eff; font-weight: bold;">Method:</span>
                        <div class="optimization-method active" data-method="bayesian">Bayesian</div>
                        <div class="optimization-method" data-method="grid">Grid Search</div>
                        <div class="optimization-method" data-method="random">Random</div>
                        <div class="optimization-method" data-method="tpe">TPE</div>
                    </div>
                    <div class="parameter-space" id="parameter-space">
                        <!-- Optimization points will be plotted here -->
                    </div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #888;">
                        <span style="color: #4ade80;">●</span> Best (Loss: 1.23)
                        <span style="color: #4a9eff; margin-left: 15px;">●</span> Good (Loss: 1.5-2.0)
                        <span style="color: #ef4444; margin-left: 15px;">●</span> Poor (Loss: >2.5)
                        <span style="color: #fbbf24; margin-left: 15px;">●</span> Current
                    </div>
                </div>
            </div>
            
            <!-- Phase 5: Distributed Training Visualization -->
            <div class="panel">
                <h3>🌐 Distributed Training</h3>
                <div class="distributed-training">
                    <div class="gpu-cluster">
                        <h5>GPU Cluster (8x A100)</h5>
                        <div class="gpu-grid" id="gpu-grid">
                            <!-- GPU nodes will be populated by JavaScript -->
                        </div>
                        <div style="font-size: 0.8em; color: #888;">
                            Gradient sync every 4 steps
                        </div>
                    </div>
                    <div class="gpu-cluster">
                        <h5>Communication Pattern</h5>
                        <div style="position: relative; height: 200px;">
                            <svg width="100%" height="200" id="communication-viz">
                                <!-- Communication lines will be drawn here -->
                            </svg>
                        </div>
                        <div style="font-size: 0.8em; color: #888;">
                            All-reduce gradient aggregation
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 5: Real-time Text Generation -->
            <div class="panel full-width">
                <h3>✨ Real-time Text Generation</h3>
                <div class="text-generation">
                    <div class="generation-controls">
                        <input type="text" id="prompt-input" class="prompt-input" placeholder="Enter a prompt to see real-time generation..." value="The future of artificial intelligence">
                        <button id="generate-btn" class="generate-btn">🚀 Generate</button>
                        <label style="color: #888;">
                            Temperature: <span id="temp-value">0.7</span>
                            <input type="range" id="temp-slider" min="0.1" max="1.5" step="0.1" value="0.7" style="margin-left: 5px;">
                        </label>
                    </div>
                    <div class="generated-text" id="generated-text">
                        <span style="color: #888;">Click "Generate" to see live text generation as the model trains...</span>
                    </div>
                </div>
            </div>
            
            <!-- Phase 5: Advanced Memory Profiler -->
            <div class="panel full-width">
                <h3>🧠 Advanced Memory Profiler</h3>
                <div class="memory-profiler">
                    <div class="memory-breakdown">
                        <div class="memory-segment weights">
                            <div class="memory-value" id="weights-memory">8.4 GB</div>
                            <div class="memory-label">Model Weights</div>
                        </div>
                        <div class="memory-segment activations">
                            <div class="memory-value" id="activations-memory">3.2 GB</div>
                            <div class="memory-label">Activations</div>
                        </div>
                        <div class="memory-segment gradients">
                            <div class="memory-value" id="gradients-memory">8.4 GB</div>
                            <div class="memory-label">Gradients</div>
                        </div>
                        <div class="memory-segment optimizer">
                            <div class="memory-value" id="optimizer-memory">16.8 GB</div>
                            <div class="memory-label">Optimizer States</div>
                        </div>
                        <div class="memory-segment cache">
                            <div class="memory-value" id="cache-memory">1.2 GB</div>
                            <div class="memory-label">KV Cache</div>
                        </div>
                    </div>
                    <h5>Memory Usage Timeline</h5>
                    <div class="memory-timeline" id="memory-timeline">
                        <!-- Memory usage visualization will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global animation state
        let animationFrame = 0;
        let isAnimating = true;
        let animationSpeed = 1;
        
        // Global visualization objects
        let progressChart, network;
        
        // Enhanced configuration for Phase 1
        let currentConfig = {
            learningRate: 0.001,
            batchSize: 32,
            dropout: 0.1,
            attentionHeads: 8,
            scheduler: 'cosine',
            warmupSteps: 100,
            maxSteps: 10000
        };
        
        // Phase 1: Training monitoring state
        let trainingHistory = {
            losses: [],
            learningRates: [],
            gradientNorms: [],
            alerts: []
        };
        
        let instabilityDetector = {
            lossSpikes: 0,
            gradientClips: 0,
            lastLoss: null,
            consecutiveIncreases: 0
        };
        
        // Phase 1: Learning Rate Scheduling Functions
        function calculateLearningRate(step, scheduler = 'cosine') {
            const baseLr = currentConfig.learningRate;
            const warmupSteps = currentConfig.warmupSteps;
            const maxSteps = currentConfig.maxSteps;
            
            // Warmup phase
            if (step < warmupSteps) {
                return baseLr * (step / warmupSteps);
            }
            
            switch (scheduler) {
                case 'constant':
                    return baseLr;
                case 'cosine':
                    const cosineProgress = (step - warmupSteps) / (maxSteps - warmupSteps);
                    return baseLr * 0.5 * (1 + Math.cos(Math.PI * cosineProgress));
                case 'step':
                    const decaySteps = Math.floor((step - warmupSteps) / 1000);
                    return baseLr * Math.pow(0.9, decaySteps);
                case 'exponential':
                    return baseLr * Math.exp(-0.0001 * (step - warmupSteps));
                case 'warmup':
                    const warmupCosine = (step - warmupSteps) / (maxSteps - warmupSteps);
                    return baseLr * 0.5 * (1 + Math.cos(Math.PI * warmupCosine));
                default:
                    return baseLr;
            }
        }
        
        // Phase 1: Training Instability Detection
        function detectInstability(currentLoss, gradientNorm) {
            const alerts = [];
            const timestamp = new Date().toLocaleTimeString();
            
            // Loss spike detection
            if (instabilityDetector.lastLoss && currentLoss > instabilityDetector.lastLoss * 1.5) {
                instabilityDetector.lossSpikes++;
                alerts.push({
                    type: 'warning',
                    icon: '⚠️',
                    message: `Loss spike detected: ${currentLoss.toFixed(3)} (prev: ${instabilityDetector.lastLoss.toFixed(3)})`,
                    timestamp
                });
            }
            
            // Gradient explosion detection
            if (gradientNorm > 10) {
                instabilityDetector.gradientClips++;
                alerts.push({
                    type: 'error',
                    icon: '💥',
                    message: `Gradient explosion: norm = ${gradientNorm.toFixed(3)}`,
                    timestamp
                });
            }
            
            // Consecutive loss increases
            if (instabilityDetector.lastLoss && currentLoss > instabilityDetector.lastLoss) {
                instabilityDetector.consecutiveIncreases++;
                if (instabilityDetector.consecutiveIncreases >= 5) {
                    alerts.push({
                        type: 'warning',
                        icon: '📈',
                        message: `Training may be diverging: ${instabilityDetector.consecutiveIncreases} consecutive increases`,
                        timestamp
                    });
                }
            } else {
                instabilityDetector.consecutiveIncreases = 0;
            }
            
            // Learning rate too high warning
            if (currentConfig.learningRate > 0.01) {
                alerts.push({
                    type: 'warning',
                    icon: '🔥',
                    message: 'Learning rate may be too high for stable training',
                    timestamp
                });
            }
            
            instabilityDetector.lastLoss = currentLoss;
            return alerts;
        }
        
        // Control panel functionality
        function initializeControls() {
            // Play/Pause/Reset buttons
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resetBtn = document.getElementById('reset-btn');
            
            playBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                isAnimating = true;
                playBtn.classList.add('active');
                pauseBtn.classList.remove('active');
                animate();
            });
            
            pauseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                isAnimating = false;
                pauseBtn.classList.add('active');
                playBtn.classList.remove('active');
            });
            
            resetBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                animationFrame = 0;
                trainingHistory = { losses: [], learningRates: [], gradientNorms: [], alerts: [] };
                instabilityDetector = { lossSpikes: 0, gradientClips: 0, lastLoss: null, consecutiveIncreases: 0 };
                document.getElementById('training-alerts').style.display = 'none';
                if(!isAnimating) {
                   updateAllVisualizations(0);
                }
            });
            
            // Speed control
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                speedValue.textContent = animationSpeed + 'x';
            });
            
            // Parameter sliders
            const params = ['lr', 'batch', 'dropout', 'heads'];
            params.forEach(param => {
                const slider = document.getElementById(`${param}-slider`);
                const value = document.getElementById(`${param}-value`);
                
                slider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    value.textContent = param === 'lr' ? val.toFixed(4) : 
                                      param === 'dropout' ? val.toFixed(2) : val;
                    
                    // Update configuration
                    switch(param) {
                        case 'lr': currentConfig.learningRate = val; break;
                        case 'batch': currentConfig.batchSize = val; break;
                        case 'dropout': currentConfig.dropout = val; break;
                        case 'heads': currentConfig.attentionHeads = val; break;
                    }
                    
                    // Update charts when parameters change
                    if (progressChart && progressChart.updateChart) {
                        progressChart.updateChart();
                    }
                });
            });
            
            // Phase 1: Scheduler controls
            document.getElementById('scheduler-select').addEventListener('change', (e) => {
                currentConfig.scheduler = e.target.value;
                if (progressChart && progressChart.updateChart) {
                    progressChart.updateChart();
                }
            });
            
            document.getElementById('warmup-steps').addEventListener('change', (e) => {
                currentConfig.warmupSteps = parseInt(e.target.value);
                if (progressChart && progressChart.updateChart) {
                    progressChart.updateChart();
                }
            });
            
            // Phase 2: Advanced model architecture controls
            
            // Attention evolution controls
            document.getElementById('evolution-head-selector').addEventListener('change', () => {
                updateAttentionEvolution(document.getElementById('evolution-timeline').value);
            });
            
            document.getElementById('evolution-layer-selector').addEventListener('change', () => {
                updateAttentionEvolution(document.getElementById('evolution-timeline').value);
            });
            
            document.getElementById('evolution-timeline').addEventListener('input', (e) => {
                updateAttentionEvolution(parseInt(e.target.value));
            });
            
            document.getElementById('play-evolution').addEventListener('click', () => {
                let progress = 0;
                const evolutionInterval = setInterval(() => {
                    progress += 2;
                    document.getElementById('evolution-timeline').value = progress;
                    updateAttentionEvolution(progress);
                    if (progress >= 100) {
                        clearInterval(evolutionInterval);
                    }
                }, 100);
            });
            
            // Capacity visualization controls
            document.getElementById('capacity-viz-type').addEventListener('change', () => {
                updateCapacityVisualization(animationFrame / 10 % 100);
            });
            
            document.getElementById('capacity-metric').addEventListener('change', () => {
                updateCapacityVisualization(animationFrame / 10 % 100);
            });
        }
        
        // Training Progress Chart (Enhanced for Phase 1)
        function createProgressChart() {
            const width = 1360;
            const height = 300;
            const margin = {top: 20, right: 80, bottom: 40, left: 60};
            
            const svg = d3.select("#progress-chart")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`);
            
            const xScale = d3.scaleLinear()
                .domain([0, 100])
                .range([margin.left, width - margin.right]);
            
            const yScale = d3.scaleLinear()
                .domain([0, 5])
                .range([height - margin.bottom, margin.top]);
            
            // Grid
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat("")
                );
            
             svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale)
                    .tickSize(-width + margin.left + margin.right)
                    .tickFormat("")
                );

            // Axes
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).tickFormat(d => d + "%"));
            
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale));
            
            // Generate data with Phase 1 enhancements
            function generateData() {
                const trainingData = [], validationData = [], lrData = [], gradientData = [];
                for (let i = 0; i <= 100; i++) {
                    const step = Math.floor(i / 100 * currentConfig.maxSteps);
                    const currentLR = calculateLearningRate(step, currentConfig.scheduler);
                    const lrEffect = currentLR * 1000;
                    
                    trainingData.push({x: i, y: (4.5 * Math.exp(-i/20) + 0.5) * (2 - lrEffect) + Math.random() * 0.1});
                    validationData.push({x: i, y: (4.5 * Math.exp(-i/25) + 0.6) * (2 - lrEffect) + Math.random() * 0.15});
                    lrData.push({x: i, y: currentLR * 1000});
                    gradientData.push({x: i, y: 1 + Math.sin(i/5) * Math.exp(-i/30) * 0.5 + Math.random() * 0.1});
                }
                return { trainingData, validationData, lrData, gradientData };
            }
            
            let initialData = generateData();

            // Line generators
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveMonotoneX);
            
            // Draw lines
            const trainPath = svg.append("path").datum(initialData.trainingData).attr("class", "loss-line").attr("d", line).attr("stroke", "#4a9eff");
            const valPath = svg.append("path").datum(initialData.validationData).attr("class", "loss-line").attr("d", line).attr("stroke", "#ff6b6b");
            const lrPath = svg.append("path").datum(initialData.lrData).attr("class", "loss-line").attr("d", line).attr("stroke", "#4ade80").attr("stroke-dasharray", "5,5");
            const gradPath = svg.append("path").datum(initialData.gradientData).attr("class", "loss-line").attr("d", line).attr("stroke", "#fbbf24").attr("stroke-dasharray", "3,3");
            
            // Progress indicator
            const progressLine = svg.append("line")
                .attr("class", "progress-indicator")
                .attr("x1", xScale(0))
                .attr("x2", xScale(0))
                .attr("y1", margin.top)
                .attr("y2", height - margin.bottom)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.8);
            
            function updateChart() {
                let newData = generateData();
                trainPath.datum(newData.trainingData).transition().duration(500).attr("d", line);
                valPath.datum(newData.validationData).transition().duration(500).attr("d", line);
                lrPath.datum(newData.lrData).transition().duration(500).attr("d", line);
                gradPath.datum(newData.gradientData).transition().duration(500).attr("d", line);
            }

            return {progressLine, xScale, updateChart};
        }
        
        // Neural Network Visualization
        function createNetworkVisualization() {
            const width = 660;
            const height = 400;
            
            const svg = d3.select("#network-viz")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`);
            
            const layers = [
                {name: "Input", neurons: 6, x: 100},
                {name: "Embedding", neurons: 8, x: 220},
                {name: "Attention", neurons: 10, x: 340},
                {name: "FFN", neurons: 8, x: 460},
                {name: "Output", neurons: 6, x: 580}
            ];
            
            const connections = svg.append("g").attr("class", "connections");
            for (let i = 0; i < layers.length - 1; i++) {
                const currentLayer = layers[i];
                const nextLayer = layers[i + 1];
                for (let j = 0; j < currentLayer.neurons; j++) {
                    for (let k = 0; k < nextLayer.neurons; k++) {
                        connections.append("line")
                            .attr("class", "connection")
                            .attr("x1", currentLayer.x + 10)
                            .attr("y1", 50 + j * (300 / (currentLayer.neurons-1)))
                            .attr("x2", nextLayer.x - 10)
                            .attr("y2", 50 + k * (300 / (nextLayer.neurons-1)));
                    }
                }
            }
            
            const neurons = svg.append("g").attr("class", "neurons");
            layers.forEach(layer => {
                for (let i = 0; i < layer.neurons; i++) {
                    neurons.append("circle")
                        .attr("class", "neuron")
                        .attr("cx", layer.x)
                        .attr("cy", 50 + i * (300 / (layer.neurons-1)))
                        .attr("r", 8);
                }
                svg.append("text").attr("x", layer.x).attr("y", 380).attr("text-anchor", "middle").attr("fill", "#888").attr("font-size", "12px").text(layer.name);
            });
            
            return {neurons, connections};
        }
        
        // Phase 1: Enhanced updateAllVisualizations function
        function updateAllVisualizations(progress) {
            const progressRatio = progress / 100;
            const currentStep = Math.floor(progressRatio * currentConfig.maxSteps);
            
            // Update progress line
            if (progressChart && progressChart.progressLine) {
                progressChart.progressLine
                    .attr("x1", progressChart.xScale(progress))
                    .attr("x2", progressChart.xScale(progress));
            }
            
            // Update metrics with Phase 1 enhancements
            const epoch = Math.floor(progressRatio * 50);
            d3.select("#epoch").text(epoch);
            d3.select("#batch").text(epoch * 512 + Math.floor(Math.random()*512));
            d3.select("#tokens").text((progressRatio * 300).toFixed(1));
            
            // Calculate dynamic learning rate
            const currentLR = calculateLearningRate(currentStep, currentConfig.scheduler);
            
            // Enhanced loss calculation with instability simulation
            const baseLoss = 5 * Math.exp(-progressRatio * 4);
            let currentLoss = baseLoss * (2 - currentLR * 1000) + Math.random() * 0.1;
            
            // Simulate occasional instability
            if (Math.random() < 0.05) {
                currentLoss *= (1 + Math.random() * 0.5); // Loss spike
            }
            
            const perplexity = (Math.exp(currentLoss + 0.2)).toFixed(1);
            d3.select("#perplexity").text(perplexity);
            
            // Calculate gradient norm
            const gradientNorm = (0.2 + baseLoss*0.1 + Math.random()*0.02);
            
            // Phase 1: Training instability detection
            const alerts = detectInstability(currentLoss, gradientNorm);
            if (alerts.length > 0) {
                const latestAlert = alerts[alerts.length - 1];
                const alertContainer = document.getElementById('training-alerts');
                const alertIcon = document.getElementById('alert-icon');
                const alertTitle = document.getElementById('alert-title');
                const alertMessage = document.getElementById('alert-message');
                
                alertContainer.style.display = 'block';
                alertContainer.className = `training-alerts ${latestAlert.type === 'error' ? 'critical' : 'warning'}`;
                alertIcon.textContent = latestAlert.icon;
                alertTitle.textContent = latestAlert.type === 'error' ? 'Critical Alert' : 'Training Warning';
                alertMessage.textContent = latestAlert.message;
                
                // Auto-hide info alerts after 5 seconds
                if (latestAlert.type === 'info') {
                    setTimeout(() => {
                        alertContainer.style.display = 'none';
                    }, 5000);
                }
            }
            
            // Phase 1: Update loss breakdown components
            const crossEntropyLoss = currentLoss * 0.95;
            const regularizationLoss = currentLoss * 0.05;
            const lossVariance = Math.abs(Math.sin(progress / 10)) * 0.2;
            const convergenceRate = Math.min(100, 60 + progressRatio * 40 + Math.random() * 5);
            const trainingEfficiency = Math.min(100, 70 + progressRatio * 30 + Math.random() * 10);
            
            d3.select("#cross-entropy-loss").text(crossEntropyLoss.toFixed(3));
            d3.select("#regularization-loss").text(regularizationLoss.toFixed(4));
            d3.select("#total-loss").text(currentLoss.toFixed(3));
            d3.select("#loss-variance").text(lossVariance.toFixed(3));
            d3.select("#convergence-rate").text(convergenceRate.toFixed(1) + '%');
            d3.select("#training-efficiency").text(trainingEfficiency.toFixed(1) + '%');
            
            // Update other standard metrics
            d3.select("#gpu-util").text((75 + Math.sin(progress * Math.PI / 10) * 15).toFixed(0) + "%");
            d3.select("#memory-use").text((10 + currentConfig.batchSize / 32 * 5 + Math.random()).toFixed(1) + "GB");
            
            // Store training history for Phase 1 analysis
            trainingHistory.losses.push(currentLoss);
            trainingHistory.learningRates.push(currentLR);
            trainingHistory.gradientNorms.push(gradientNorm);
            
            // Keep only last 1000 points for performance
            if (trainingHistory.losses.length > 1000) {
                trainingHistory.losses.shift();
                trainingHistory.learningRates.shift();
                trainingHistory.gradientNorms.shift();
            }
            
            // Phase 2: Update advanced model architecture visualizations
            
            // Update layer health indicators
            if (document.querySelector('.layer-item')) {
                document.querySelectorAll('.layer-item').forEach((item, index) => {
                    const layerId = parseInt(item.dataset.layerId);
                    const health = calculateLayerHealth(layerId, progress);
                    const healthIndicator = item.querySelector('.layer-health');
                    if (healthIndicator) {
                        healthIndicator.className = `layer-health ${health}`;
                    }
                });
                
                // Update selected layer details if any
                const activeLayer = document.querySelector('.layer-item.active');
                if (activeLayer) {
                    const layerId = parseInt(activeLayer.dataset.layerId);
                    selectLayer(layerId); // Refresh the details
                }
            }
            
            // Update attention evolution if visible
            if (document.getElementById('attention-evolution-viz').children.length > 0) {
                updateAttentionEvolution(progress);
            }
            
            // Update capacity visualization if visible
            if (document.querySelector('.capacity-rect')) {
                updateCapacityVisualization(progress);
            }
            
            // Phase 3: Update data pipeline and tokenization visualizations
            updateBatchVisualization();
            updateDataPipelineStats();
            
            // Phase 4: Update performance optimization and analytics
            updatePerformanceMetrics();
            updateResourceGauges();
        }
        
        // Phase 2: Advanced Model Architecture Functions
        
        // Layer definitions for analysis
        const modelLayers = [
            { id: 0, name: 'Token Embedding', type: 'embedding', params: 50331648 },
            { id: 1, name: 'Position Embedding', type: 'embedding', params: 2097152 },
            { id: 2, name: 'Layer 1 - Attention', type: 'attention', params: 4194304 },
            { id: 3, name: 'Layer 1 - FFN', type: 'ffn', params: 16777216 },
            { id: 4, name: 'Layer 2 - Attention', type: 'attention', params: 4194304 },
            { id: 5, name: 'Layer 2 - FFN', type: 'ffn', params: 16777216 },
            { id: 6, name: 'Layer 3 - Attention', type: 'attention', params: 4194304 },
            { id: 7, name: 'Layer 3 - FFN', type: 'ffn', params: 16777216 },
            { id: 8, name: 'Layer 4 - Attention', type: 'attention', params: 4194304 },
            { id: 9, name: 'Layer 4 - FFN', type: 'ffn', params: 16777216 },
            { id: 10, name: 'Output Layer', type: 'output', params: 50331648 }
        ];
        
        // Phase 2: Layer health simulation
        function calculateLayerHealth(layerId, progress) {
            const layer = modelLayers[layerId];
            const progressRatio = progress / 100;
            
            // Simulate different layer behaviors
            let health = 0.8; // Base health
            
            if (layer.type === 'attention') {
                // Attention layers can be sensitive to learning rate
                if (currentConfig.learningRate > 0.005) health -= 0.3;
                health += Math.sin(progressRatio * Math.PI) * 0.2; // Learning curve
            } else if (layer.type === 'ffn') {
                // FFN layers are more stable
                health += progressRatio * 0.2;
                if (currentConfig.dropout > 0.3) health -= 0.1;
            } else if (layer.type === 'embedding') {
                // Embedding layers converge quickly
                health = Math.min(0.95, 0.5 + progressRatio * 0.5);
            }
            
            // Add some realistic noise
            health += (Math.random() - 0.5) * 0.1;
            health = Math.max(0, Math.min(1, health));
            
            if (health > 0.8) return 'healthy';
            if (health > 0.6) return 'warning';
            return 'critical';
        }
        
        // Phase 2: Generate layer statistics
        function generateLayerStats(layerId, progress) {
            const layer = modelLayers[layerId];
            const progressRatio = progress / 100;
            
            // Simulate realistic layer statistics
            const activationMean = (Math.random() - 0.5) * 0.2;
            const activationStd = 0.3 + Math.random() * 0.4;
            const weightMagnitude = Math.exp(-progressRatio * 2) * (0.5 + Math.random() * 0.5);
            const gradientNorm = (0.1 + Math.random() * 0.3) * Math.exp(-progressRatio);
            const sparsity = progressRatio * 0.3 + Math.random() * 0.2;
            const updates = Math.floor(progressRatio * 1000 + Math.random() * 100);
            
            return {
                activationMean: activationMean.toFixed(4),
                activationStd: activationStd.toFixed(4),
                weightMagnitude: weightMagnitude.toFixed(4),
                gradientNorm: gradientNorm.toFixed(4),
                sparsity: (sparsity * 100).toFixed(1) + '%',
                updates: updates.toLocaleString()
            };
        }
        
        // Phase 2: Create layer list
        function createLayerList() {
            const layerList = document.getElementById('layer-list');
            layerList.innerHTML = '';
            
            modelLayers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.dataset.layerId = layer.id;
                
                const health = calculateLayerHealth(layer.id, animationFrame / 10 % 100);
                
                layerItem.innerHTML = `
                    <div>
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-stats">${(layer.params / 1000000).toFixed(1)}M params</div>
                    </div>
                    <div class="layer-health ${health}"></div>
                `;
                
                layerItem.addEventListener('click', () => selectLayer(layer.id));
                layerList.appendChild(layerItem);
            });
        }
        
        // Phase 2: Select layer for detailed analysis
        function selectLayer(layerId) {
            // Update selected layer UI
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.layerId) === layerId) {
                    item.classList.add('active');
                }
            });
            
            const layer = modelLayers[layerId];
            const progress = animationFrame / 10 % 100;
            const stats = generateLayerStats(layerId, progress);
            
            // Update layer details
            document.getElementById('selected-layer-name').textContent = layer.name;
            
            const metricsContainer = document.getElementById('layer-metrics');
            metricsContainer.innerHTML = `
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.activationMean}</span>
                    <span class="layer-metric-label">Activation Mean</span>
                </div>
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.activationStd}</span>
                    <span class="layer-metric-label">Activation Std</span>
                </div>
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.weightMagnitude}</span>
                    <span class="layer-metric-label">Weight Magnitude</span>
                </div>
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.gradientNorm}</span>
                    <span class="layer-metric-label">Gradient Norm</span>
                </div>
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.sparsity}</span>
                    <span class="layer-metric-label">Sparsity</span>
                </div>
                <div class="layer-metric">
                    <span class="layer-metric-value">${stats.updates}</span>
                    <span class="layer-metric-label">Updates</span>
                </div>
            `;
            
            // Create weight distribution histogram
            createLayerHistogram(layerId);
        }
        
        // Phase 2: Create layer histogram
        function createLayerHistogram(layerId) {
            const container = document.getElementById('layer-histogram');
            container.innerHTML = '';
            
            const width = 400;
            const height = 150;
            const margin = {top: 10, right: 20, bottom: 30, left: 40};
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            // Generate histogram data
            const data = [];
            const bins = 20;
            for (let i = 0; i < bins; i++) {
                const x = (i - bins/2) / (bins/4); // Range from -2.5 to 2.5
                const y = Math.exp(-(x * x) / 2) * (50 + Math.random() * 30); // Normal distribution
                data.push({x: x, y: y});
            }
            
            const xScale = d3.scaleLinear()
                .domain(d3.extent(data, d => d.x))
                .range([margin.left, width - margin.right]);
            
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.y)])
                .range([height - margin.bottom, margin.top]);
            
            // Draw bars
            svg.selectAll('.histogram-bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'histogram-bar')
                .attr('x', d => xScale(d.x))
                .attr('y', d => yScale(d.y))
                .attr('width', (width - margin.left - margin.right) / bins * 0.8)
                .attr('height', d => height - margin.bottom - yScale(d.y));
            
            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(5))
                .selectAll('text')
                .style('fill', '#888')
                .style('font-size', '10px');
            
            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale).ticks(3))
                .selectAll('text')
                .style('fill', '#888')
                .style('font-size', '10px');
        }
        
        // Phase 2: Attention evolution functions
        function createAttentionEvolution() {
            const width = 660;
            const height = 300;
            
            const svg = d3.select("#attention-evolution-viz")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`);
            
            const gridSize = 12;
            const cellSize = Math.min((width - 40) / gridSize, (height - 40) / gridSize);
            const startX = (width - gridSize * cellSize) / 2;
            const startY = (height - gridSize * cellSize) / 2;
            
            // Create attention grid
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    svg.append("rect")
                        .attr("class", "attention-cell")
                        .attr("x", startX + i * cellSize)
                        .attr("y", startY + j * cellSize)
                        .attr("width", cellSize - 1)
                        .attr("height", cellSize - 1)
                        .attr("stroke", "#333")
                        .attr("stroke-width", 0.5);
                }
            }
            
            return { svg, gridSize, cellSize, startX, startY };
        }
        
        // Phase 2: Update attention evolution visualization
        function updateAttentionEvolution(progress = 50) {
            const head = parseInt(document.getElementById('evolution-head-selector').value);
            const layer = parseInt(document.getElementById('evolution-layer-selector').value);
            
            const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([0, 1]);
            
            d3.selectAll(".attention-cell")
                .transition()
                .duration(300)
                .attr("fill", function(d, i) {
                    const row = Math.floor(i / 12);
                    const col = i % 12;
                    
                    // Generate attention pattern based on progress, head, and layer
                    let value;
                    const progressFactor = progress / 100;
                    
                    if (head < 2) { // Early heads focus on position
                        value = Math.exp(-Math.abs(row - col) / (3 + progressFactor * 2)) * progressFactor;
                    } else if (head < 4) { // Later heads learn syntax
                        value = (row === col + 1 || row === col - 1) ? 0.8 * progressFactor : 
                               (row % 3 === col % 3) ? 0.4 * progressFactor : Math.random() * 0.2 * progressFactor;
                    } else { // Advanced heads learn semantics
                        value = (Math.sin((row + col + head) / 4) * Math.cos((row - col) / 3) + 1) / 2 * progressFactor;
                    }
                    
                    // Layer depth affects pattern complexity
                    value *= (layer + 4) / 16;
                    
                    return colorScale(Math.max(0, Math.min(1, value)));
                });
        }
        
        // Phase 2: Model capacity visualization
        function createCapacityVisualization() {
            const width = 660;
            const height = 200;
            
            const svg = d3.select("#capacity-heatmap")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`);
            
            // Create capacity heatmap for layers
            const layers = modelLayers.length;
            const layerWidth = width / layers;
            const layerHeight = height - 40;
            
            modelLayers.forEach((layer, i) => {
                const rect = svg.append("rect")
                    .attr("class", "capacity-rect")
                    .attr("x", i * layerWidth)
                    .attr("y", 20)
                    .attr("width", layerWidth - 2)
                    .attr("height", layerHeight)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1);
                
                // Add layer label
                svg.append("text")
                    .attr("x", i * layerWidth + layerWidth / 2)
                    .attr("y", 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#888")
                    .attr("font-size", "10px")
                    .text(`L${i + 1}`);
            });
            
            return svg;
        }
        
        // Phase 2: Update capacity visualization
        function updateCapacityVisualization(progress = 50) {
            const metric = document.getElementById('capacity-metric').value;
            const colorScale = d3.scaleSequential(d3.interpolateRdYlBu).domain([0, 1]);
            
            d3.selectAll(".capacity-rect")
                .transition()
                .duration(500)
                .attr("fill", function(d, i) {
                    let value;
                    const progressRatio = progress / 100;
                    const layer = modelLayers[i];
                    
                    switch(metric) {
                        case 'magnitude':
                            value = Math.exp(-progressRatio * 1.5) * (0.3 + Math.random() * 0.7);
                            if (layer.type === 'attention') value *= 1.2;
                            break;
                        case 'sparsity':
                            value = progressRatio * 0.4 + Math.random() * 0.3;
                            if (layer.type === 'ffn') value *= 1.3;
                            break;
                        case 'updates':
                            value = progressRatio * (0.5 + Math.random() * 0.5);
                            break;
                        default:
                            value = Math.random();
                    }
                    
                    return colorScale(Math.max(0, Math.min(1, value)));
                });
        }
        
        // Phase 2: Initialize tab functionality
        function initializeTabSystem() {
            document.querySelectorAll('.viz-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.viz-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.viz-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    tab.classList.add('active');
                    const tabName = tab.dataset.tab;
                    document.getElementById(tabName).classList.add('active');
                });
            });
        }
        
        // Phase 3: Data Pipeline & Tokenization Functions
        
        // Sample vocabulary for tokenization demo
        const sampleVocabulary = {
            '<pad>': 0, '<s>': 1, '</s>': 2, '<unk>': 3,
            'the': 4, 'a': 5, 'an': 6, 'and': 7, 'or': 8, 'but': 9, 'in': 10, 'on': 11, 'at': 12, 'to': 13, 'for': 14, 'of': 15, 'with': 16, 'by': 17,
            'is': 18, 'are': 19, 'was': 20, 'were': 21, 'be': 22, 'been': 23, 'being': 24, 'have': 25, 'has': 26, 'had': 27, 'do': 28, 'does': 29, 'did': 30,
            'will': 31, 'would': 32, 'could': 33, 'should': 34, 'can': 35, 'may': 36, 'might': 37, 'must': 38,
            'i': 39, 'you': 40, 'he': 41, 'she': 42, 'it': 43, 'we': 44, 'they': 45, 'this': 46, 'that': 47, 'these': 48, 'those': 49,
            'quick': 50, 'brown': 51, 'fox': 52, 'jumps': 53, 'over': 54, 'lazy': 55, 'dog': 56, 'cat': 57, 'bird': 58, 'fish': 59,
            'hello': 60, 'world': 61, 'good': 62, 'bad': 63, 'big': 64, 'small': 65, 'fast': 66, 'slow': 67, 'hot': 68, 'cold': 69,
            'red': 70, 'blue': 71, 'green': 72, 'yellow': 73, 'black': 74, 'white': 75, 'up': 76, 'down': 77, 'left': 78, 'right': 79,
            'one': 80, 'two': 81, 'three': 82, 'four': 83, 'five': 84, 'six': 85, 'seven': 86, 'eight': 87, 'nine': 88, 'ten': 89
        };
        
        // Phase 3: Simple tokenization function
        function tokenizeText(text) {
            // Simple word-based tokenization for demo purposes
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(word => word.length > 0);
            
            const tokens = [];
            words.forEach(word => {
                if (sampleVocabulary.hasOwnProperty(word)) {
                    tokens.push({
                        text: word,
                        id: sampleVocabulary[word],
                        type: 'known'
                    });
                } else {
                    // Handle unknown words with subword tokenization simulation
                    if (word.length > 3) {
                        const chunks = [];
                        for (let i = 0; i < word.length; i += 3) {
                            chunks.push(word.slice(i, i + 3));
                        }
                        chunks.forEach((chunk, idx) => {
                            tokens.push({
                                text: chunk,
                                id: 3, // <unk> token
                                type: 'subword',
                                original: word,
                                part: idx + 1,
                                totalParts: chunks.length
                            });
                        });
                    } else {
                        tokens.push({
                            text: word,
                            id: 3, // <unk> token
                            type: 'unknown'
                        });
                    }
                }
            });
            
            return tokens;
        }
        
        // Phase 3: Update tokenizer demo
        function updateTokenizerDemo() {
            const input = document.getElementById('tokenizer-input').value;
            const tokens = tokenizeText(input);
            
            // Display tokenized output
            const outputDiv = document.getElementById('tokenizer-output');
            outputDiv.innerHTML = tokens.map(token => {
                let className = 'token-item';
                let title = `Token: ${token.text}\nID: ${token.id}\nType: ${token.type}`;
                
                if (token.type === 'subword') {
                    title += `\nOriginal: ${token.original}\nPart: ${token.part}/${token.totalParts}`;
                }
                
                return `<span class="${className}" title="${title}">
                    ${token.text}<span class="token-id">[${token.id}]</span>
                </span>`;
            }).join('');
            
            // Display encoding process
            const processDiv = document.getElementById('encoding-process');
            const steps = [
                {
                    title: '1. Text Preprocessing',
                    content: `Original: "${input}"\nLowercase + Punctuation removal`
                },
                {
                    title: '2. Word Segmentation', 
                    content: `Words: [${input.toLowerCase().replace(/[^\w\s]/g, ' ').split(/\s+/).filter(w => w).join(', ')}]`
                },
                {
                    title: '3. Vocabulary Lookup',
                    content: `Tokens: ${tokens.length}\nUnknown words: ${tokens.filter(t => t.type === 'unknown' || t.type === 'subword').length}`
                },
                {
                    title: '4. Token IDs',
                    content: `IDs: [${tokens.map(t => t.id).join(', ')}]`
                }
            ];
            
            processDiv.innerHTML = steps.map(step => `
                <div class="encoding-step">
                    <div class="encoding-step-title">${step.title}</div>
                    <div class="encoding-step-content">${step.content}</div>
                </div>
            `).join('');
        }
        
        // Phase 3: Create token frequency chart
        function createTokenFrequencyChart() {
            const container = d3.select("#token-frequency-chart");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 200;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Generate sample token frequency data
            const tokenFreqs = [
                { token: 'the', freq: 1240 },
                { token: 'a', freq: 890 },
                { token: 'and', freq: 750 },
                { token: 'to', freq: 680 },
                { token: 'of', freq: 620 },
                { token: 'in', freq: 580 },
                { token: 'is', freq: 520 },
                { token: 'for', freq: 480 },
                { token: 'with', freq: 420 },
                { token: 'on', freq: 380 },
                { token: 'as', freq: 340 },
                { token: 'be', freq: 310 },
                { token: 'have', freq: 290 },
                { token: 'at', freq: 270 },
                { token: 'by', freq: 250 }
            ];
            
            const xScale = d3.scaleBand()
                .domain(tokenFreqs.map(d => d.token))
                .range([margin.left, width - margin.right])
                .padding(0.2);
                
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(tokenFreqs, d => d.freq)])
                .range([height - margin.bottom, margin.top]);
            
            // Create bars
            svg.selectAll(".bar")
                .data(tokenFreqs)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.token))
                .attr("y", height - margin.bottom)
                .attr("width", xScale.bandwidth())
                .attr("height", 0)
                .attr("fill", "#4a9eff")
                .attr("opacity", 0.7)
                .transition()
                .duration(1000)
                .attr("y", d => yScale(d.freq))
                .attr("height", d => height - margin.bottom - yScale(d.freq));
            
            // Add axes
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale))
                .attr("color", "#888");
                
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale).ticks(5))
                .attr("color", "#888");
        }
        
        // Phase 3: Create sequence length distribution chart
        function createSequenceLengthChart() {
            const container = d3.select("#sequence-length-dist");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 150;
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Generate sample sequence length distribution
            const lengthDist = [];
            for (let i = 16; i <= 512; i += 16) {
                const freq = Math.max(0, 100 * Math.exp(-Math.pow((i - 128) / 80, 2)));
                lengthDist.push({ length: i, frequency: freq });
            }
            
            const xScale = d3.scaleLinear()
                .domain(d3.extent(lengthDist, d => d.length))
                .range([margin.left, width - margin.right]);
                
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(lengthDist, d => d.frequency)])
                .range([height - margin.bottom, margin.top]);
            
            const line = d3.line()
                .x(d => xScale(d.length))
                .y(d => yScale(d.frequency))
                .curve(d3.curveCardinal);
            
            // Create line
            svg.append("path")
                .datum(lengthDist)
                .attr("fill", "none")
                .attr("stroke", "#4ade80")
                .attr("stroke-width", 2)
                .attr("d", line);
            
            // Add area under curve
            const area = d3.area()
                .x(d => xScale(d.length))
                .y0(height - margin.bottom)
                .y1(d => yScale(d.frequency))
                .curve(d3.curveCardinal);
                
            svg.append("path")
                .datum(lengthDist)
                .attr("fill", "#4ade80")
                .attr("fill-opacity", 0.3)
                .attr("d", area);
            
            // Add axes
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(6))
                .attr("color", "#888");
                
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale).ticks(4))
                .attr("color", "#888");
        }
        
        // Phase 3: Update batch composition visualization
        function updateBatchVisualization() {
            const batchGrid = document.getElementById('batch-grid');
            const batchSize = currentConfig.batchSize;
            const maxSeqLength = 512;
            
            batchGrid.innerHTML = '';
            
            // Generate sample batch data
            for (let i = 0; i < Math.min(batchSize, 16); i++) { // Show max 16 sequences for visualization
                const seqDiv = document.createElement('div');
                seqDiv.className = 'batch-sequence';
                
                // Random sequence length with normal distribution around 127
                const seqLength = Math.max(20, Math.min(maxSeqLength, 
                    Math.round(127 + (Math.random() - 0.5) * 200)));
                
                // Create tokens for this sequence
                for (let j = 0; j < maxSeqLength / 8; j++) { // Scale down for visualization
                    const tokenDiv = document.createElement('div');
                    tokenDiv.className = 'batch-token';
                    
                    if (j * 8 < seqLength) {
                        if (j === 0) {
                            tokenDiv.classList.add('special'); // Start token
                        } else if (j * 8 >= seqLength - 8) {
                            tokenDiv.classList.add('special'); // End token
                        } else {
                            tokenDiv.classList.add('text'); // Regular text token
                        }
                    } else {
                        tokenDiv.classList.add('padding'); // Padding token
                    }
                    
                    seqDiv.appendChild(tokenDiv);
                }
                
                batchGrid.appendChild(seqDiv);
            }
            
            // Update batch statistics
            const avgSeqLength = 127 + Math.sin(animationFrame * 0.01) * 20;
            const paddingRatio = Math.max(5, 25 - avgSeqLength * 0.1);
            const batchEfficiency = Math.max(60, 100 - paddingRatio);
            const diversity = 0.8 + Math.sin(animationFrame * 0.02) * 0.15;
            const effectiveTokens = Math.round(batchSize * avgSeqLength * (batchEfficiency / 100));
            const wastedCompute = 100 - batchEfficiency;
            
            document.getElementById('avg-seq-length').textContent = Math.round(avgSeqLength);
            document.getElementById('padding-ratio').textContent = paddingRatio.toFixed(1) + '%';
            document.getElementById('batch-efficiency-value').textContent = batchEfficiency.toFixed(1) + '%';
            document.getElementById('efficiency-fill').style.width = batchEfficiency + '%';
            document.getElementById('batch-diversity').textContent = diversity.toFixed(2);
            document.getElementById('effective-tokens').textContent = effectiveTokens.toLocaleString();
            document.getElementById('wasted-compute').textContent = wastedCompute.toFixed(1) + '%';
        }
        
        // Phase 3: Update data pipeline statistics
        function updateDataPipelineStats() {
            // Simulate dynamic statistics
            const vocabSize = 32000;
            const uniqueTokens = 8432 + Math.floor(Math.sin(animationFrame * 0.005) * 200);
            const oovRate = 2.3 + Math.sin(animationFrame * 0.008) * 0.5;
            const maxSeqLength = 512;
            
            document.getElementById('vocab-size').textContent = vocabSize.toLocaleString();
            document.getElementById('unique-tokens').textContent = uniqueTokens.toLocaleString();
            document.getElementById('oov-rate').textContent = oovRate.toFixed(1) + '%';
            document.getElementById('max-seq-length').textContent = maxSeqLength;
        }
        
        // Phase 3: Initialize tokenizer demo
        function initializeTokenizerDemo() {
            const tokenizeBtn = document.getElementById('tokenize-btn');
            const inputArea = document.getElementById('tokenizer-input');
            
            tokenizeBtn.addEventListener('click', updateTokenizerDemo);
            inputArea.addEventListener('input', updateTokenizerDemo);
            
            // Initial tokenization
            updateTokenizerDemo();
        }
        
        // Phase 3: Initialize data pipeline components
        function initializeDataPipeline() {
            createTokenFrequencyChart();
            createSequenceLengthChart();
            initializeTokenizerDemo();
            updateBatchVisualization();
            updateDataPipelineStats();
        }
        
        // Phase 4: Performance Optimization & Analytics Functions
        
        // Performance monitoring state
        let performanceMetrics = {
            trainingEfficiency: 94.2,
            gpuUtilization: 87.4,
            memoryEfficiency: 76.8,
            throughput: 2340,
            costEfficiency: 0.024,
            convergenceTime: 2.4,
            trends: {
                trainingEfficiency: 'up',
                gpuUtilization: 'stable',
                memoryEfficiency: 'down',
                throughput: 'up',
                costEfficiency: 'stable',
                convergenceTime: 'up'
            }
        };
        
        // Phase 4: Update performance metrics
        function updatePerformanceMetrics() {
            // Simulate realistic performance variations
            const progress = animationFrame / 100;
            
            // Training efficiency improves as training progresses
            performanceMetrics.trainingEfficiency = 85 + 15 * Math.sin(progress * 0.1) + Math.random() * 2;
            
            // GPU utilization fluctuates based on batch processing
            performanceMetrics.gpuUtilization = 80 + 15 * Math.sin(progress * 0.05) + Math.random() * 5;
            
            // Memory efficiency decreases as model grows but improves with optimization
            performanceMetrics.memoryEfficiency = 70 + 20 * Math.sin(progress * 0.03) + Math.random() * 3;
            
            // Throughput varies with optimizations
            performanceMetrics.throughput = 2000 + 500 * Math.sin(progress * 0.08) + Math.random() * 100;
            
            // Cost efficiency improves with better resource utilization
            performanceMetrics.costEfficiency = 0.02 + 0.01 * Math.sin(progress * 0.04) + Math.random() * 0.005;
            
            // Update DOM elements
            document.getElementById('training-efficiency').textContent = performanceMetrics.trainingEfficiency.toFixed(1) + '%';
            document.getElementById('gpu-utilization').textContent = performanceMetrics.gpuUtilization.toFixed(1) + '%';
            document.getElementById('memory-efficiency').textContent = performanceMetrics.memoryEfficiency.toFixed(1) + '%';
            document.getElementById('throughput').textContent = Math.round(performanceMetrics.throughput).toLocaleString();
            document.getElementById('cost-efficiency').textContent = '$' + performanceMetrics.costEfficiency.toFixed(3);
            document.getElementById('convergence-time').textContent = performanceMetrics.convergenceTime.toFixed(1) + 'h';
            
            // Update performance value colors based on thresholds
            updatePerformanceColors();
        }
        
        // Phase 4: Update performance indicator colors
        function updatePerformanceColors() {
            const elements = [
                { id: 'training-efficiency', value: performanceMetrics.trainingEfficiency, thresholds: [90, 80, 70] },
                { id: 'gpu-utilization', value: performanceMetrics.gpuUtilization, thresholds: [85, 70, 50] },
                { id: 'memory-efficiency', value: performanceMetrics.memoryEfficiency, thresholds: [85, 70, 60] }
            ];
            
            elements.forEach(({ id, value, thresholds }) => {
                const element = document.getElementById(id);
                element.className = 'performance-value';
                
                if (value >= thresholds[0]) {
                    element.classList.add('excellent');
                } else if (value >= thresholds[1]) {
                    element.classList.add('good');
                } else if (value >= thresholds[2]) {
                    element.classList.add('warning');
                } else {
                    element.classList.add('critical');
                }
            });
        }
        
        // Phase 4: Generate optimization recommendations
        function generateOptimizationRecommendations() {
            const recommendations = [];
            
            if (performanceMetrics.memoryEfficiency < 80) {
                recommendations.push({
                    title: 'Memory Optimization Required',
                    description: 'Consider gradient checkpointing or reducing batch size to improve memory efficiency.',
                    impact: 'high',
                    expectedImprovement: '+12% memory efficiency'
                });
            }
            
            if (performanceMetrics.gpuUtilization < 75) {
                recommendations.push({
                    title: 'GPU Underutilization Detected',
                    description: 'Increase batch size or enable mixed precision training to better utilize GPU resources.',
                    impact: 'medium',
                    expectedImprovement: '+15% GPU utilization'
                });
            }
            
            if (performanceMetrics.trainingEfficiency < 90) {
                recommendations.push({
                    title: 'Learning Rate Schedule Optimization',
                    description: 'Consider using a more aggressive learning rate schedule or warmup strategy.',
                    impact: 'medium',
                    expectedImprovement: '+8% training efficiency'
                });
            }
            
            recommendations.push({
                title: 'Data Pipeline Optimization',
                description: 'Implement data prefetching and async loading to reduce I/O bottlenecks.',
                impact: 'low',
                expectedImprovement: '+5% overall throughput'
            });
            
            recommendations.push({
                title: 'Model Architecture Review',
                description: 'Consider using more efficient attention mechanisms or layer normalization.',
                impact: 'medium',
                expectedImprovement: '+10% computational efficiency'
            });
            
            return recommendations;
        }
        
        // Phase 4: Update optimization recommendations
        function updateOptimizationRecommendations() {
            const recommendations = generateOptimizationRecommendations();
            const container = document.getElementById('recommendations-list');
            
            container.innerHTML = recommendations.map(rec => `
                <div class="recommendation-item ${rec.impact}-impact">
                    <div class="recommendation-title">${rec.title}</div>
                    <div class="recommendation-description">${rec.description}</div>
                    <div class="recommendation-impact">Expected improvement: ${rec.expectedImprovement}</div>
                </div>
            `).join('');
        }
        
        // Phase 4: Update resource gauges
        function updateResourceGauges() {
            const gpuMemoryUsage = 60 + 25 * Math.sin(animationFrame * 0.02) + Math.random() * 10;
            const cpuUsage = 30 + 20 * Math.sin(animationFrame * 0.015) + Math.random() * 8;
            
            // Update GPU memory gauge
            const gpuGauge = document.getElementById('gpu-memory-gauge');
            const gpuText = document.getElementById('gpu-memory-text');
            if (gpuGauge && gpuText) {
                const circumference = 2 * Math.PI * 45;
                const strokeDasharray = (gpuMemoryUsage / 100) * circumference;
                gpuGauge.setAttribute('stroke-dasharray', `${strokeDasharray} ${circumference}`);
                gpuText.textContent = Math.round(gpuMemoryUsage) + '%';
                
                // Update gauge color based on usage
                if (gpuMemoryUsage > 90) {
                    gpuGauge.setAttribute('stroke', '#ef4444');
                } else if (gpuMemoryUsage > 75) {
                    gpuGauge.setAttribute('stroke', '#fbbf24');
                } else {
                    gpuGauge.setAttribute('stroke', '#4a9eff');
                }
            }
            
            // Update CPU usage gauge
            const cpuGauge = document.getElementById('cpu-usage-gauge');
            const cpuText = document.getElementById('cpu-usage-text');
            if (cpuGauge && cpuText) {
                const circumference = 2 * Math.PI * 45;
                const strokeDasharray = (cpuUsage / 100) * circumference;
                cpuGauge.setAttribute('stroke-dasharray', `${strokeDasharray} ${circumference}`);
                cpuText.textContent = Math.round(cpuUsage) + '%';
                
                // Update gauge color based on usage
                if (cpuUsage > 80) {
                    cpuGauge.setAttribute('stroke', '#ef4444');
                } else if (cpuUsage > 60) {
                    cpuGauge.setAttribute('stroke', '#fbbf24');
                } else {
                    cpuGauge.setAttribute('stroke', '#4ade80');
                }
            }
        }
        
        // Phase 4: Create resource timeline heatmap
        function createResourceTimelineHeatmap() {
            const container = d3.select("#resource-timeline-heatmap");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 200;
            const margin = { top: 20, right: 20, bottom: 20, left: 80 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Generate sample resource data
            const resources = ['GPU Memory', 'GPU Compute', 'CPU', 'Memory', 'I/O'];
            const timePoints = 50;
            const data = [];
            
            resources.forEach((resource, resourceIdx) => {
                for (let t = 0; t < timePoints; t++) {
                    const baseValue = 0.3 + 0.4 * Math.sin(t * 0.1 + resourceIdx);
                    const noise = (Math.random() - 0.5) * 0.2;
                    data.push({
                        resource: resource,
                        time: t,
                        usage: Math.max(0, Math.min(1, baseValue + noise))
                    });
                }
            });
            
            const xScale = d3.scaleLinear()
                .domain([0, timePoints - 1])
                .range([margin.left, width - margin.right]);
                
            const yScale = d3.scaleBand()
                .domain(resources)
                .range([margin.top, height - margin.bottom])
                .padding(0.1);
                
            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([0, 1]);
            
            // Create heatmap cells
            svg.selectAll(".heatmap-cell")
                .data(data)
                .enter().append("rect")
                .attr("class", "heatmap-cell")
                .attr("x", d => xScale(d.time))
                .attr("y", d => yScale(d.resource))
                .attr("width", xScale(1) - xScale(0))
                .attr("height", yScale.bandwidth())
                .attr("fill", d => colorScale(d.usage))
                .append("title")
                .text(d => `${d.resource}: ${(d.usage * 100).toFixed(1)}%`);
            
            // Add y-axis labels
            svg.selectAll(".y-label")
                .data(resources)
                .enter().append("text")
                .attr("class", "y-label")
                .attr("x", margin.left - 10)
                .attr("y", d => yScale(d) + yScale.bandwidth() / 2)
                .attr("text-anchor", "end")
                .attr("dominant-baseline", "middle")
                .attr("fill", "#888")
                .attr("font-size", "12px")
                .text(d => d);
        }
        
        // Phase 4: Update bottleneck analysis
        function updateBottleneckAnalysis() {
            const bottlenecks = [
                { component: 'Data Loading', severity: 'low', impact: '2.3%' },
                { component: 'Forward Pass', severity: 'medium', impact: '12.1%' },
                { component: 'Backward Pass', severity: 'high', impact: '8.7%' },
                { component: 'Optimizer Step', severity: 'low', impact: '1.4%' },
                { component: 'Attention Computation', severity: 'medium', impact: '15.2%' },
                { component: 'Memory Allocation', severity: 'high', impact: '6.8%' }
            ];
            
            const container = document.getElementById('bottleneck-list');
            container.innerHTML = bottlenecks.map(bottleneck => `
                <div class="bottleneck-item">
                    <div class="bottleneck-component">${bottleneck.component}</div>
                    <div>
                        <span class="bottleneck-severity ${bottleneck.severity}">${bottleneck.severity.toUpperCase()}</span>
                        <span style="margin-left: 10px; color: #888;">${bottleneck.impact}</span>
                    </div>
                </div>
            `).join('');
        }
        
        // Phase 4: Initialize analytics tab system
        function initializeAnalyticsTabSystem() {
            const tabs = document.querySelectorAll('.analytics-tab');
            const contents = document.querySelectorAll('.analytics-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding content
                    const targetTab = tab.dataset.tab;
                    const targetContent = document.getElementById(targetTab);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });
        }
        
        // Phase 4: Initialize timeline controls
        function initializeTimelineControls() {
            const playBtn = document.getElementById('timeline-play');
            const slider = document.getElementById('timeline-slider');
            const timeDisplay = document.getElementById('timeline-time');
            
            if (playBtn) {
                playBtn.addEventListener('click', () => {
                    // Toggle play/pause for timeline
                    const isPlaying = playBtn.textContent === '⏸️';
                    playBtn.textContent = isPlaying ? '▶️' : '⏸️';
                });
            }
            
            if (slider) {
                slider.addEventListener('input', (e) => {
                    const progress = parseInt(e.target.value);
                    const hours = Math.floor(progress * 0.1);
                    const minutes = Math.floor((progress * 0.1 - hours) * 60);
                    const seconds = Math.floor(((progress * 0.1 - hours) * 60 - minutes) * 60);
                    
                    if (timeDisplay) {
                        timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                });
            }
        }
        
        // Phase 4: Initialize performance optimization components
        function initializePerformanceOptimization() {
            updatePerformanceMetrics();
            updateOptimizationRecommendations();
            updateResourceGauges();
            createResourceTimelineHeatmap();
            updateBottleneckAnalysis();
            initializeAnalyticsTabSystem();
            initializeTimelineControls();
        }
        
        // Phase 5: Advanced Training Features Functions
        
        // Model comparison state
        let modelComparison = {
            modelA: {
                name: 'GPT-3.5 (Base)',
                loss: 2.47,
                perplexity: 11.8,
                accuracy: 76.2,
                speed: 2100,
                progress: 65,
                architecture: '12L-768H-12A'
            },
            modelB: {
                name: 'GPT-4 (Optimized)', 
                loss: 1.89,
                perplexity: 6.6,
                accuracy: 84.7,
                speed: 1800,
                progress: 58,
                architecture: '24L-1024H-16A'
            }
        };
        
        // Hyperparameter optimization state
        let optimizationState = {
            method: 'bayesian',
            trials: [],
            currentBest: { lr: 0.0015, batchSize: 64, dropout: 0.1, loss: 1.23 },
            currentTrial: { lr: 0.001, batchSize: 32, dropout: 0.1, loss: 2.47 }
        };
        
        // Text generation state
        let textGeneration = {
            prompt: '',
            generatedText: '',
            isGenerating: false,
            temperature: 0.7,
            tokens: []
        };
        
        // Memory profiling state
        let memoryProfile = {
            weights: 8.4,
            activations: 3.2,
            gradients: 8.4,
            optimizer: 16.8,
            cache: 1.2,
            timeline: []
        };
        
        // Phase 5: Update model comparison metrics
        function updateModelComparison() {
            const progress = animationFrame / 100;
            
            // Update Model A (GPT-3.5)
            modelComparison.modelA.loss = 2.8 * Math.exp(-progress * 2) + 0.2 + Math.random() * 0.1;
            modelComparison.modelA.perplexity = Math.exp(modelComparison.modelA.loss) + Math.random() * 0.5;
            modelComparison.modelA.accuracy = 60 + 25 * (1 - Math.exp(-progress * 1.5)) + Math.random() * 2;
            modelComparison.modelA.speed = 2000 + 200 * Math.sin(progress * 0.1) + Math.random() * 100;
            modelComparison.modelA.progress = Math.min(95, progress * 1.5 + Math.random() * 2);
            
            // Update Model B (GPT-4) - converges faster but starts higher
            modelComparison.modelB.loss = 2.2 * Math.exp(-progress * 3) + 0.15 + Math.random() * 0.08;
            modelComparison.modelB.perplexity = Math.exp(modelComparison.modelB.loss) + Math.random() * 0.3;
            modelComparison.modelB.accuracy = 70 + 20 * (1 - Math.exp(-progress * 2)) + Math.random() * 1.5;
            modelComparison.modelB.speed = 1700 + 150 * Math.sin(progress * 0.08) + Math.random() * 80;
            modelComparison.modelB.progress = Math.min(95, progress * 1.2 + Math.random() * 2);
            
            // Update DOM elements
            document.getElementById('model-a-loss').textContent = modelComparison.modelA.loss.toFixed(2);
            document.getElementById('model-a-perplexity').textContent = modelComparison.modelA.perplexity.toFixed(1);
            document.getElementById('model-a-accuracy').textContent = modelComparison.modelA.accuracy.toFixed(1) + '%';
            document.getElementById('model-a-speed').textContent = Math.round(modelComparison.modelA.speed / 1000 * 10) / 10 + 'k';
            document.getElementById('model-a-progress').style.width = modelComparison.modelA.progress + '%';
            
            document.getElementById('model-b-loss').textContent = modelComparison.modelB.loss.toFixed(2);
            document.getElementById('model-b-perplexity').textContent = modelComparison.modelB.perplexity.toFixed(1);
            document.getElementById('model-b-accuracy').textContent = modelComparison.modelB.accuracy.toFixed(1) + '%';
            document.getElementById('model-b-speed').textContent = Math.round(modelComparison.modelB.speed / 1000 * 10) / 10 + 'k';
            document.getElementById('model-b-progress').style.width = modelComparison.modelB.progress + '%';
        }
        
        // Phase 5: Create hyperparameter optimization visualization
        function createHyperparameterSpace() {
            const container = document.getElementById('parameter-space');
            if (!container) return;
            
            // Clear existing points
            container.innerHTML = '';
            
            // Generate optimization trials
            for (let i = 0; i < 50; i++) {
                const lr = Math.random() * 0.009 + 0.0001; // 0.0001 to 0.01
                const batchSize = Math.floor(Math.random() * 120) + 8; // 8 to 128
                const dropout = Math.random() * 0.5; // 0 to 0.5
                
                // Simulate loss based on parameters (lower is better)
                const lrPenalty = Math.abs(lr - 0.001) * 1000; // Optimal around 0.001
                const batchPenalty = Math.abs(batchSize - 32) * 0.01; // Optimal around 32
                const dropoutPenalty = Math.abs(dropout - 0.1) * 2; // Optimal around 0.1
                const loss = 1.2 + lrPenalty + batchPenalty + dropoutPenalty + Math.random() * 0.5;
                
                const point = document.createElement('div');
                point.className = 'optimization-point';
                
                // Position based on learning rate (x) and batch size (y)
                const x = (Math.log10(lr) - Math.log10(0.0001)) / (Math.log10(0.01) - Math.log10(0.0001)) * 100;
                const y = (batchSize - 8) / (128 - 8) * 100;
                
                point.style.left = x + '%';
                point.style.top = (100 - y) + '%'; // Invert Y axis
                
                // Color based on performance
                if (loss < 1.5) {
                    point.classList.add('best');
                } else if (loss < 2.0) {
                    point.classList.add('good');
                } else {
                    point.classList.add('poor');
                }
                
                point.title = `LR: ${lr.toFixed(4)}, Batch: ${batchSize}, Dropout: ${dropout.toFixed(2)}, Loss: ${loss.toFixed(2)}`;
                container.appendChild(point);
            }
            
            // Add current point
            const currentPoint = document.createElement('div');
            currentPoint.className = 'optimization-point current';
            const currentX = (Math.log10(optimizationState.currentTrial.lr) - Math.log10(0.0001)) / (Math.log10(0.01) - Math.log10(0.0001)) * 100;
            const currentY = (optimizationState.currentTrial.batchSize - 8) / (128 - 8) * 100;
            currentPoint.style.left = currentX + '%';
            currentPoint.style.top = (100 - currentY) + '%';
            currentPoint.title = 'Current Configuration';
            container.appendChild(currentPoint);
        }
        
        // Phase 5: Initialize GPU cluster visualization
        function initializeGPUCluster() {
            const gpuGrid = document.getElementById('gpu-grid');
            if (!gpuGrid) return;
            
            gpuGrid.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                const gpuNode = document.createElement('div');
                gpuNode.className = 'gpu-node';
                gpuNode.textContent = `GPU ${i + 1}`;
                gpuNode.id = `gpu-${i}`;
                
                gpuNode.addEventListener('click', () => {
                    // Toggle GPU selection
                    gpuNode.classList.toggle('active');
                });
                
                gpuGrid.appendChild(gpuNode);
            }
            
            // Simulate communication pattern
            setInterval(() => {
                if (isAnimating) {
                    const nodes = document.querySelectorAll('.gpu-node');
                    nodes.forEach(node => node.classList.remove('communicating'));
                    
                    // Randomly select nodes for communication
                    const activeNodes = Array.from(nodes).filter(() => Math.random() > 0.6);
                    activeNodes.forEach(node => node.classList.add('communicating'));
                }
            }, 2000);
        }
        
        // Phase 5: Text generation simulation
        function simulateTextGeneration() {
            if (textGeneration.isGenerating) return;
            
            const prompt = document.getElementById('prompt-input').value;
            const outputDiv = document.getElementById('generated-text');
            
            if (!prompt.trim()) return;
            
            textGeneration.isGenerating = true;
            textGeneration.prompt = prompt;
            textGeneration.generatedText = prompt;
            
            // Simulate progressive text generation
            const possibleContinuations = [
                ' will revolutionize how we work and live.',
                ' represents a significant breakthrough in computational intelligence.',
                ' continues to evolve at an unprecedented pace.',
                ' offers both tremendous opportunities and important challenges.',
                ' is transforming industries across the globe.',
                ' requires careful consideration of ethical implications.',
                ' demonstrates remarkable capabilities in reasoning and creativity.',
                ' will likely reshape education, healthcare, and scientific research.',
                ' represents one of the most significant technological advances of our time.',
                ' continues to surprise researchers with its emergent capabilities.'
            ];
            
            const words = possibleContinuations[Math.floor(Math.random() * possibleContinuations.length)].split(' ');
            let currentIndex = 0;
            
            outputDiv.innerHTML = `<span class="generated-token">${prompt}</span>`;
            
            const generateInterval = setInterval(() => {
                if (currentIndex < words.length && isAnimating) {
                    const newToken = document.createElement('span');
                    newToken.className = 'generated-token new';
                    newToken.textContent = words[currentIndex];
                    outputDiv.appendChild(newToken);
                    
                    // Remove 'new' class after animation
                    setTimeout(() => {
                        newToken.classList.remove('new');
                    }, 500);
                    
                    currentIndex++;
                } else {
                    clearInterval(generateInterval);
                    textGeneration.isGenerating = false;
                }
            }, 300 + Math.random() * 500); // Variable timing for realism
        }
        
        // Phase 5: Update memory profiler
        function updateMemoryProfiler() {
            // Simulate dynamic memory usage
            const progress = animationFrame / 100;
            
            memoryProfile.weights = 8.4 + Math.sin(progress * 0.05) * 0.2;
            memoryProfile.activations = 2.8 + 1.0 * Math.sin(progress * 0.1) + Math.random() * 0.3;
            memoryProfile.gradients = memoryProfile.weights + Math.random() * 0.1;
            memoryProfile.optimizer = memoryProfile.weights * 2 + Math.random() * 0.2;
            memoryProfile.cache = 0.8 + 0.8 * Math.sin(progress * 0.08) + Math.random() * 0.1;
            
            // Update DOM elements
            document.getElementById('weights-memory').textContent = memoryProfile.weights.toFixed(1) + ' GB';
            document.getElementById('activations-memory').textContent = memoryProfile.activations.toFixed(1) + ' GB';
            document.getElementById('gradients-memory').textContent = memoryProfile.gradients.toFixed(1) + ' GB';
            document.getElementById('optimizer-memory').textContent = memoryProfile.optimizer.toFixed(1) + ' GB';
            document.getElementById('cache-memory').textContent = memoryProfile.cache.toFixed(1) + ' GB';
            
            // Create memory timeline visualization
            createMemoryTimeline();
        }
        
        // Phase 5: Create memory timeline visualization
        function createMemoryTimeline() {
            const container = d3.select("#memory-timeline");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 100;
            const margin = { top: 10, right: 10, bottom: 10, left: 10 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Generate memory usage data over time
            const timePoints = 50;
            const memoryTypes = [
                { name: 'weights', color: '#4a9eff', base: 8.4 },
                { name: 'activations', color: '#4ade80', base: 3.2 },
                { name: 'gradients', color: '#fbbf24', base: 8.4 },
                { name: 'optimizer', color: '#ef4444', base: 16.8 },
                { name: 'cache', color: '#a855f7', base: 1.2 }
            ];
            
            const stackData = [];
            for (let t = 0; t < timePoints; t++) {
                const point = { time: t };
                let cumulative = 0;
                
                memoryTypes.forEach(type => {
                    const variation = type.base * 0.1 * Math.sin(t * 0.1 + type.base) + Math.random() * 0.5;
                    const value = Math.max(0.1, type.base + variation);
                    point[type.name] = value;
                    point[type.name + '_start'] = cumulative;
                    cumulative += value;
                    point[type.name + '_end'] = cumulative;
                });
                
                stackData.push(point);
            }
            
            const xScale = d3.scaleLinear()
                .domain([0, timePoints - 1])
                .range([margin.left, width - margin.right]);
                
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(stackData, d => memoryTypes.reduce((sum, type) => sum + d[type.name], 0))])
                .range([height - margin.bottom, margin.top]);
            
            // Create stacked areas
            memoryTypes.forEach(type => {
                const area = d3.area()
                    .x(d => xScale(d.time))
                    .y0(d => yScale(d[type.name + '_start']))
                    .y1(d => yScale(d[type.name + '_end']))
                    .curve(d3.curveCardinal);
                    
                svg.append("path")
                    .datum(stackData)
                    .attr("fill", type.color)
                    .attr("fill-opacity", 0.7)
                    .attr("d", area);
            });
        }
        
        // Phase 5: Initialize optimization method controls
        function initializeOptimizationControls() {
            const methods = document.querySelectorAll('.optimization-method');
            methods.forEach(method => {
                method.addEventListener('click', () => {
                    methods.forEach(m => m.classList.remove('active'));
                    method.classList.add('active');
                    optimizationState.method = method.dataset.method;
                    createHyperparameterSpace(); // Regenerate with new method
                });
            });
        }
        
        // Phase 5: Initialize text generation controls
        function initializeTextGenerationControls() {
            const generateBtn = document.getElementById('generate-btn');
            const tempSlider = document.getElementById('temp-slider');
            const tempValue = document.getElementById('temp-value');
            
            if (generateBtn) {
                generateBtn.addEventListener('click', simulateTextGeneration);
            }
            
            if (tempSlider && tempValue) {
                tempSlider.addEventListener('input', (e) => {
                    textGeneration.temperature = parseFloat(e.target.value);
                    tempValue.textContent = textGeneration.temperature.toFixed(1);
                });
            }
        }
        
        // Phase 5: Initialize advanced training features
        function initializeAdvancedTraining() {
            createHyperparameterSpace();
            initializeGPUCluster();
            initializeOptimizationControls();
            initializeTextGenerationControls();
            updateMemoryProfiler();
        }
        
        // Initialize all visualizations
        progressChart = createProgressChart();
        network = createNetworkVisualization();
        
        initializeControls();
        
        // Phase 2: Initialize advanced model architecture components
        createLayerList();
        initializeTabSystem();
        
        // Initialize attention evolution visualization
        const attentionEvolution = createAttentionEvolution();
        
        // Initialize capacity visualization
        const capacityViz = createCapacityVisualization();
        
        // Phase 3: Initialize data pipeline components
        initializeDataPipeline();
        
        // Phase 4: Initialize performance optimization components
        initializePerformanceOptimization();
        
        // Set initial states
        selectLayer(0); // Select first layer by default
        updateAttentionEvolution(50); // Set initial attention state
        updateCapacityVisualization(50); // Set initial capacity state
        
        // Main Animation loop (Enhanced for Phase 1)
        function animate() {
            if (!isAnimating) return;
            animationFrame += animationSpeed;
            const progress = (animationFrame / 10) % 100;
            updateAllVisualizations(progress);
            
            // Animate network
            if (animationFrame % 10 < animationSpeed) {
                network.neurons.selectAll(".neuron").classed("active", () => Math.random() > 0.8 - currentConfig.dropout);
                network.connections.selectAll(".connection").classed("active", () => Math.random() > 0.95);
            }
            
            // Update layer list and details
            createLayerList();
            const activeLayerId = parseInt(document.querySelector('.layer-item.active')?.dataset.layerId) || 0;
            selectLayer(activeLayerId);
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Global click handler for play/pause
        document.body.addEventListener('click', (e) => {
            // Don't toggle if clicking on controls
            if (e.target.closest('.control-btn, .panel, select, input')) return;
            
            isAnimating = !isAnimating;
            document.getElementById('play-btn').classList.toggle('active', isAnimating);
            document.getElementById('pause-btn').classList.toggle('active', !isAnimating);
            if (isAnimating) animate();
        });
    </script>
</body>
</html>
